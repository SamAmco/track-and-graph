return {
  functions={
    ["a1-test"]={
      script="-- Example function demonstrating all available configuration types\n-- This function showcases text, number, checkbox, enum, and uint inputs\n\nlocal tng_config = require(\"tng.config\")\nlocal text = tng_config.text\nlocal number = tng_config.number\nlocal checkbox = tng_config.checkbox\nlocal enum = tng_config.enum\nlocal uint = tng_config.uint\n\nreturn {\n\9id = \"a1-test\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = { \"_transform\" },\n\9title = {\n\9\9[\"en\"] = \"Configuration Types Demo\",\n\9\9[\"de\"] = \"Konfigurationstypen-Demo\",\n\9\9[\"es\"] = \"Demostración de tipos de configuración\",\n\9\9[\"fr\"] = \"Démonstration des types de configuration\",\n\9},\n\9description = {\n\9\9[\"en\"] =\n\9\9\"Demonstrates all available configuration input types: text, number, checkbox, enum, and uint. This function passes through all data points unchanged.\",\n\9\9[\"de\"] =\n\9\9\"Demonstriert alle verfügbaren Konfigurationseingabetypen: Text, Nummer, Kontrollkästchen, Aufzählung und uint. Diese Funktion gibt alle Datenpunkte unverändert weiter.\",\n\9\9[\"es\"] =\n\9\9\"Demuestra todos los tipos de entrada de configuración disponibles: texto, número, casilla de verificación, enumeración y uint. Esta función pasa todos los puntos de datos sin cambios.\",\n\9\9[\"fr\"] =\n\9\9\"Démontre tous les types d'entrée de configuration disponibles : texte, nombre, case à cocher, énumération et uint. Cette fonction transmet tous les points de données inchangés.\",\n\9},\n\9config = {\n\9\9text {\n\9\9\9id = \"text_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Text Input\",\n\9\9\9\9[\"de\"] = \"Texteingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de texto\",\n\9\9\9\9[\"fr\"] = \"Saisie de texte\",\n\9\9\9},\n\9\9\9default = \"Example text\",\n\9\9},\n\9\9number {\n\9\9\9id = \"number_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Number Input\",\n\9\9\9\9[\"de\"] = \"Zahleneingabe\",\n\9\9\9\9[\"es\"] = \"Entrada numérica\",\n\9\9\9\9[\"fr\"] = \"Saisie numérique\",\n\9\9\9},\n\9\9\9default = 3.14,\n\9\9},\n\9\9checkbox {\n\9\9\9id = \"checkbox_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Checkbox Input\",\n\9\9\9\9[\"de\"] = \"Kontrollkästchen\",\n\9\9\9\9[\"es\"] = \"Casilla de verificación\",\n\9\9\9\9[\"fr\"] = \"Case à cocher\",\n\9\9\9},\n\9\9\9default = true,\n\9\9},\n\9\9enum {\n\9\9\9id = \"enum_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Enum Input\",\n\9\9\9\9[\"de\"] = \"Aufzählungseingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de enumeración\",\n\9\9\9\9[\"fr\"] = \"Saisie d'énumération\",\n\9\9\9},\n\9\9\9options = { \"_hours\", \"_days\", \"_weeks\" },\n\9\9\9default = \"_days\",\n\9\9},\n\9\9uint {\n\9\9\9id = \"uint_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Unsigned Integer Input\",\n\9\9\9\9[\"de\"] = \"Vorzeichenlose Ganzzahleingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de entero sin signo\",\n\9\9\9\9[\"fr\"] = \"Saisie d'entier non signé\",\n\9\9\9},\n\9\9\9default = 42,\n\9\9},\n\9},\n\n\9generator = function(source, config)\n\9\9-- Access configuration values (not used in this demo)\n\9\9local text_val = config and config.text_example\n\9\9local number_val = config and config.number_example\n\9\9local checkbox_val = config and config.checkbox_example\n\9\9local enum_val = config and config.enum_example\n\9\9local uint_val = config and config.uint_example\n\n\9\9-- Pass through all data points unchanged\n\9\9return function()\n\9\9\9return source.dp()\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["absolute-value"]={
      script="-- Lua Function to take absolute value\n-- Converts all data point values to their absolute value\n\nreturn {\n\9-- Configuration metadata\n\9id = \"absolute-value\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Absolute Value\",\n\9\9[\"de\"] = \"Absolutwert\",\n\9\9[\"es\"] = \"Valor absoluto\",\n\9\9[\"fr\"] = \"Valeur absolue\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Converts each data point's value to its absolute value (removes negative sign).\",\n\9\9[\"de\"] = \"Konvertiert den Wert jedes Datenpunkts zu seinem Absolutwert (entfernt negatives Vorzeichen).\",\n\9\9[\"es\"] = \"Convierte el valor de cada punto de datos a su valor absoluto (elimina el signo negativo).\",\n\9\9[\"fr\"] = \"Convertit la valeur de chaque point de données en sa valeur absolue (supprime le signe négatif).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Convert to absolute value\n\9\9\9data_point.value = math.abs(data_point.value)\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ceil={
      script="-- Lua Function to ceiling values\n-- Rounds each data point's value up to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"ceil\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Ceiling\",\n\9\9[\"de\"] = \"Aufrunden\",\n\9\9[\"es\"] = \"Techo\",\n\9\9[\"fr\"] = \"Plafond\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[Rounds each data point's value up to the nearest multiple of a specified number.\n\nConfiguration:\n• Nearest: Round up to the nearest multiple of this number (default: 1.0)]],\n\9\9[\"de\"] = [[Rundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl auf.\n\nKonfiguration:\n• Nächste: Auf das nächste Vielfache dieser Zahl aufrunden (Standard: 1.0)]],\n\9\9[\"es\"] = [[Redondea hacia arriba el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n• Más cercano: Redondear hacia arriba al múltiplo más cercano de este número (predeterminado: 1.0)]],\n\9\9[\"fr\"] = [[Arrondit vers le haut la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n• Plus proche: Arrondir vers le haut au multiple le plus proche de ce nombre (par défaut: 1.0)]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Ceiling to nearest multiple\n\9\9\9data_point.value = math.ceil(data_point.value / nearest) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["distinct-until-changed"]={
      script="-- Lua Function to filter out consecutive duplicates based on selected fields\n-- Only passes through data points when the selected fields change from the previous one\n\nlocal enum = require(\"tng.config\").enum\n\nreturn {\n\9-- Configuration metadata\n\9id = \"distinct-until-changed\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = { \"_filter\" },\n\9title = {\n\9\9[\"en\"] = \"Distinct Until Changed\",\n\9\9[\"de\"] = \"Eindeutig bis geändert\",\n\9\9[\"es\"] = \"Distinto hasta cambio\",\n\9\9[\"fr\"] = \"Distinct jusqu'au changement\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Filters out consecutive duplicates based on the selected fields. Only data points where the selected fields differ from the previous one will pass through.\\n\\n• All Fields - Compare value, label, and note\\n• Value Only - Compare value only\\n• Label Only - Compare label only\\n• Note Only - Compare note only\\n• Value and Label - Compare value and label\\n• Value and Note - Compare value and note\\n• Label and Note - Compare label and note\",\n\9\9[\"de\"] = \"Filtert aufeinanderfolgende Duplikate basierend auf den ausgewählten Feldern heraus. Nur Datenpunkte, bei denen sich die ausgewählten Felder vom vorherigen unterscheiden, werden durchgelassen.\\n\\n• Alle Felder - Vergleicht Wert, Label und Notiz\\n• Nur Wert - Vergleicht nur Wert\\n• Nur Label - Vergleicht nur Label\\n• Nur Notiz - Vergleicht nur Notiz\\n• Wert und Label - Vergleicht Wert und Label\\n• Wert und Notiz - Vergleicht Wert und Notiz\\n• Label und Notiz - Vergleicht Label und Notiz\",\n\9\9[\"es\"] = \"Filtra duplicados consecutivos basándose en los campos seleccionados. Solo los puntos de datos donde los campos seleccionados difieren del anterior pasarán.\\n\\n• Todos los campos - Compara valor, etiqueta y nota\\n• Solo valor - Compara solo valor\\n• Solo etiqueta - Compara solo etiqueta\\n• Solo nota - Compara solo nota\\n• Valor y etiqueta - Compara valor y etiqueta\\n• Valor y nota - Compara valor y nota\\n• Etiqueta y nota - Compara etiqueta y nota\",\n\9\9[\"fr\"] = \"Filtre les doublons consécutifs en fonction des champs sélectionnés. Seuls les points de données où les champs sélectionnés diffèrent du précédent passeront.\\n\\n• Tous les champs - Compare valeur, étiquette et note\\n• Valeur uniquement - Compare la valeur uniquement\\n• Étiquette uniquement - Compare l'étiquette uniquement\\n• Note uniquement - Compare la note uniquement\\n• Valeur et étiquette - Compare valeur et étiquette\\n• Valeur et note - Compare valeur et note\\n• Étiquette et note - Compare étiquette et note\",\n\9},\n\9config = {\n\9\9enum {\n\9\9\9id = \"compare_by\",\n\9\9\9name = \"_compare_by\",\n\9\9\9options = {\n\9\9\9\9\"_all_fields\",\n\9\9\9\9\"_value_only\",\n\9\9\9\9\"_label_only\",\n\9\9\9\9\"_note_only\",\n\9\9\9\9\"_value_and_label\",\n\9\9\9\9\"_value_and_note\",\n\9\9\9\9\"_label_and_note\",\n\9\9\9},\n\9\9\9default = \"_all_fields\",\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local compare_by = config and config.compare_by or \"_all_fields\"\n\n\9\9local last_value = nil\n\9\9local last_label = nil\n\9\9local last_note = nil\n\n\9\9return function()\n\9\9\9while true do\n\9\9\9\9local data_point = source.dp()\n\9\9\9\9if not data_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\n\9\9\9\9local current_value = data_point.value\n\9\9\9\9local current_label = data_point.label\n\9\9\9\9local current_note = data_point.note\n\n\9\9\9\9local is_different = false\n\n\9\9\9\9if compare_by == \"_all_fields\" then\n\9\9\9\9\9is_different = (current_value ~= last_value)\n\9\9\9\9\9\9or (current_label ~= last_label)\n\9\9\9\9\9\9or (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_value_only\" then\n\9\9\9\9\9is_different = (current_value ~= last_value)\n\9\9\9\9elseif compare_by == \"_label_only\" then\n\9\9\9\9\9is_different = (current_label ~= last_label)\n\9\9\9\9elseif compare_by == \"_note_only\" then\n\9\9\9\9\9is_different = (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_value_and_label\" then\n\9\9\9\9\9is_different = (current_value ~= last_value) or (current_label ~= last_label)\n\9\9\9\9elseif compare_by == \"_value_and_note\" then\n\9\9\9\9\9is_different = (current_value ~= last_value) or (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_label_and_note\" then\n\9\9\9\9\9is_different = (current_label ~= last_label) or (current_note ~= last_note)\n\9\9\9\9end\n\n\9\9\9\9if is_different then\n\9\9\9\9\9last_value = current_value\n\9\9\9\9\9last_label = current_label\n\9\9\9\9\9last_note = current_note\n\9\9\9\9\9return data_point\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    divide={
      script="-- Lua Function to divide data point values by a configurable number\n-- This function divides all incoming data point values by a specified divisor\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"divide\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Divide Values\",\n        [\"de\"] = \"Werte dividieren\",\n        [\"es\"] = \"Dividir Valores\",\n        [\"fr\"] = \"Diviser les Valeurs\"\n    },\n    description = {\n        [\"en\"] = [[Divides all incoming data point values by a specified divisor.\n\nConfiguration:\n• Divisor: The number to divide all values by (default: 1.0)]],\n        [\"de\"] = [[Dividiert alle eingehenden Datenpunktwerte durch einen bestimmten Divisor.\n\nKonfiguration:\n• Divisor: Die Zahl, durch die alle Werte dividiert werden (Standard: 1.0)]],\n        [\"es\"] = [[Divide todos los valores de puntos de datos entrantes por un divisor especificado.\n\nConfiguración:\n• Divisor: El número por el cual dividir todos los valores (predeterminado: 1.0)]],\n        [\"fr\"] = [[Divise toutes les valeurs de points de données entrantes par un diviseur spécifié.\n\nConfiguration:\n• Diviseur: Le nombre par lequel diviser toutes les valeurs (par défaut: 1.0)]]\n    },\n    config = {\n        number {\n            id = \"divisor\",\n            default = 1.0,\n            name = {\n                [\"en\"] = \"Divisor\",\n                [\"de\"] = \"Divisor\",\n                [\"es\"] = \"Divisor\",\n                [\"fr\"] = \"Diviseur\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local divisor = config and config.divisor or 1.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value / divisor\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["filter-after-first"]={
      script="-- Lua Function to filter data points after a reference point\n-- Outputs all data points from the first source that come after the first point in the second source\n\nreturn {\n\9-- Configuration metadata\n\9id = \"filter-after-first\",\n\9version = \"1.0.0\",\n\9inputCount = 2,\n\9categories = {\"_filter\"},\n\9title = {\n\9\9[\"en\"] = \"Filter After First\",\n\9\9[\"de\"] = \"Filtern nach Erstem\",\n\9\9[\"es\"] = \"Filtrar después del primero\",\n\9\9[\"fr\"] = \"Filtrer après le premier\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[Filters data points from the first input source to only include those that occur after the first data point in the second input source.\n\nThis is useful for filtering data based on a reference event or timestamp from another tracker.]],\n\9\9[\"de\"] = [[Filtert Datenpunkte aus der ersten Eingabequelle, um nur diejenigen einzuschließen, die nach dem ersten Datenpunkt in der zweiten Eingabequelle auftreten.\n\nDies ist nützlich zum Filtern von Daten basierend auf einem Referenzereignis oder Zeitstempel von einem anderen Tracker.]],\n\9\9[\"es\"] = [[Filtra puntos de datos de la primera fuente de entrada para incluir solo aquellos que ocurren después del primer punto de datos en la segunda fuente de entrada.\n\nEsto es útil para filtrar datos basados en un evento de referencia o marca de tiempo de otro rastreador.]],\n\9\9[\"fr\"] = [[Filtre les points de données de la première source d'entrée pour n'inclure que ceux qui se produisent après le premier point de données de la deuxième source d'entrée.\n\nCeci est utile pour filtrer les données basées sur un événement de référence ou un horodatage d'un autre tracker.]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(sources, config)\n\9\9local source1 = sources[1]\n\9\9local source2 = sources[2]\n\9\9local cutoff_timestamp = nil\n\n\9\9return function()\n\9\9\9-- Initialize cutoff on first call\n\9\9\9if cutoff_timestamp == nil then\n\9\9\9\9local reference_point = source2.dp()\n\9\9\9\9cutoff_timestamp = reference_point and reference_point.timestamp\n\9\9\9end\n\n\9\9\9-- Get next point from source1 and check if it's after cutoff\n\9\9\9local data_point = source1.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Data points are in reverse chronological order, so \"after\" means greater timestamp\n\9\9\9if not cutoff_timestamp or data_point.timestamp > cutoff_timestamp then\n\9\9\9\9return data_point\n\9\9\9end\n\n\9\9\9-- If the data point is not after the cutoff we're done\n\9\9\9return nil\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["filter-by-label"]={
      script="-- Example Lua Function with Input Count and Configuration\n-- This function filters data points by label\n\nlocal text = require(\"tng.config\").text\nlocal checkbox = require(\"tng.config\").checkbox\n\nlocal function match(data_point, filter_label, case_sensitive, match_exactly)\n    if filter_label == nil then\n        return true\n    end\n\n    local data_label = data_point.label\n    if not data_label then return false end\n\n    -- Apply case sensitivity\n    if not case_sensitive then\n        data_label = string.lower(data_label)\n        filter_label = string.lower(filter_label)\n    end\n\n    -- Apply matching mode\n    if match_exactly then\n        return data_label == filter_label\n    else\n        return string.find(data_label, filter_label, 1, true) ~= nil\n    end\nend\n\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-by-label\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter by Label\",\n        [\"de\"] = \"Filtern nach Etikett\",\n        [\"es\"] = \"Filtrar por Etiqueta\",\n        [\"fr\"] = \"Filtrer par Étiquette\"\n    },\n    description = {\n        [\"en\"] = [[Filters data points by their label field. Only data points matching the filter criteria will pass through.\n\nConfiguration:\n• Filter Label: The text to search for in labels\n• Case Sensitive: Match case exactly (default: false)\n• Match Exactly: Require exact match instead of substring (default: false)\n• Invert: Keep data points that DON'T match instead (default: false)]],\n        [\"de\"] = [[Filtert Datenpunkte nach ihrem Label-Feld. Nur Datenpunkte, die den Filterkriterien entsprechen, werden durchgelassen.\n\nKonfiguration:\n• Filter-Label: Der Text, nach dem in Labels gesucht werden soll\n• Groß-/Kleinschreibung beachten: Groß-/Kleinschreibung exakt beachten (Standard: false)\n• Exakt übereinstimmen: Exakte Übereinstimmung statt Teilstring erforderlich (Standard: false)\n• Invertieren: Datenpunkte behalten, die NICHT übereinstimmen (Standard: false)]],\n        [\"es\"] = [[Filtra puntos de datos por su campo de etiqueta. Solo los puntos de datos que coincidan con los criterios del filtro pasarán.\n\nConfiguración:\n• Filtrar Etiqueta: El texto a buscar en las etiquetas\n• Sensible a Mayúsculas: Coincidir exactamente con mayúsculas y minúsculas (predeterminado: false)\n• Coincidir Exactamente: Requerir coincidencia exacta en lugar de subcadena (predeterminado: false)\n• Invertir: Mantener puntos de datos que NO coincidan (predeterminado: false)]],\n        [\"fr\"] = [[Filtre les points de données par leur champ d'étiquette. Seuls les points de données correspondant aux critères du filtre passeront.\n\nConfiguration:\n• Filtrer l'Étiquette: Le texte à rechercher dans les étiquettes\n• Sensible à la Casse: Correspondance exacte de la casse (par défaut: false)\n• Correspondance Exacte: Nécessite une correspondance exacte au lieu d'une sous-chaîne (par défaut: false)\n• Inverser: Conserver les points de données qui NE correspondent PAS (par défaut: false)]]\n    },\n    config = {\n        text {\n            id = \"filter_label\",\n            name = {\n                [\"en\"] = \"Filter Label\",\n                [\"de\"] = \"Filter-Label\",\n                [\"es\"] = \"Filtrar Etiqueta\",\n                [\"fr\"] = \"Filtrer l'Étiquette\"\n            }\n        },\n        checkbox {\n            id = \"case_sensitive\",\n            name = {\n                [\"en\"] = \"Case Sensitive\",\n                [\"de\"] = \"Groß-/Kleinschreibung beachten\",\n                [\"es\"] = \"Sensible a Mayúsculas\",\n                [\"fr\"] = \"Sensible à la Casse\"\n            }\n        },\n        checkbox {\n            id = \"match_exactly\",\n            name = {\n                [\"en\"] = \"Match Exactly\",\n                [\"de\"] = \"Exakt übereinstimmen\",\n                [\"es\"] = \"Coincidir Exactamente\",\n                [\"fr\"] = \"Correspondance Exacte\"\n            }\n        },\n        checkbox {\n            id = \"invert\",\n            name = {\n                [\"en\"] = \"Invert\",\n                [\"de\"] = \"Invertieren\",\n                [\"es\"] = \"Invertir\",\n                [\"fr\"] = \"Inverser\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local filter_label = config and config.filter_label\n        local case_sensitive = config and config.case_sensitive or false\n        local match_exactly = config and config.match_exactly or false\n        local invert = config and config.invert or false\n\n        return function()\n            local data_point = source.dp()\n            local should_match = not invert\n            while data_point and (match(data_point, filter_label, case_sensitive, match_exactly) ~= should_match) do\n                data_point = source.dp()\n            end\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["filter-by-note"]={
      script="-- Lua Function to filter data points by note\n-- This function filters data points by note\n\nlocal text = require(\"tng.config\").text\nlocal checkbox = require(\"tng.config\").checkbox\n\nlocal function match(data_point, filter_note, case_sensitive, match_exactly)\n    if filter_note == nil then\n        return true\n    end\n\n    local data_note = data_point.note\n    if not data_note then return false end\n\n    -- Apply case sensitivity\n    if not case_sensitive then\n        data_note = string.lower(data_note)\n        filter_note = string.lower(filter_note)\n    end\n\n    -- Apply matching mode\n    if match_exactly then\n        return data_note == filter_note\n    else\n        return string.find(data_note, filter_note, 1, true) ~= nil\n    end\nend\n\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-by-note\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter by Note\",\n        [\"de\"] = \"Filtern nach Notiz\",\n        [\"es\"] = \"Filtrar por Nota\",\n        [\"fr\"] = \"Filtrer par Note\"\n    },\n    description = {\n        [\"en\"] = [[Filters data points by their note field. Only data points matching the filter criteria will pass through.\n\nConfiguration:\n• Filter Note: The text to search for in notes\n• Case Sensitive: Match case exactly (default: false)\n• Match Exactly: Require exact match instead of substring (default: false)\n• Invert: Keep data points that DON'T match instead (default: false)]],\n        [\"de\"] = [[Filtert Datenpunkte nach ihrem Notiz-Feld. Nur Datenpunkte, die den Filterkriterien entsprechen, werden durchgelassen.\n\nKonfiguration:\n• Filter-Notiz: Der Text, nach dem in Notizen gesucht werden soll\n• Groß-/Kleinschreibung beachten: Groß-/Kleinschreibung exakt beachten (Standard: false)\n• Exakt übereinstimmen: Exakte Übereinstimmung statt Teilstring erforderlich (Standard: false)\n• Invertieren: Datenpunkte behalten, die NICHT übereinstimmen (Standard: false)]],\n        [\"es\"] = [[Filtra puntos de datos por su campo de nota. Solo los puntos de datos que coincidan con los criterios del filtro pasarán.\n\nConfiguración:\n• Filtrar Nota: El texto a buscar en las notas\n• Sensible a Mayúsculas: Coincidir exactamente con mayúsculas y minúsculas (predeterminado: false)\n• Coincidir Exactamente: Requerir coincidencia exacta en lugar de subcadena (predeterminado: false)\n• Invertir: Mantener puntos de datos que NO coincidan (predeterminado: false)]],\n        [\"fr\"] = [[Filtre les points de données par leur champ de note. Seuls les points de données correspondant aux critères du filtre passeront.\n\nConfiguration:\n• Filtrer la Note: Le texte à rechercher dans les notes\n• Sensible à la Casse: Correspondance exacte de la casse (par défaut: false)\n• Correspondance Exacte: Nécessite une correspondance exacte au lieu d'une sous-chaîne (par défaut: false)\n• Inverser: Conserver les points de données qui NE correspondent PAS (par défaut: false)]]\n    },\n    config = {\n        text {\n            id = \"filter_note\",\n            name = {\n                [\"en\"] = \"Filter Note\",\n                [\"de\"] = \"Filter-Notiz\",\n                [\"es\"] = \"Filtrar Nota\",\n                [\"fr\"] = \"Filtrer la Note\"\n            }\n        },\n        checkbox {\n            id = \"case_sensitive\",\n            name = {\n                [\"en\"] = \"Case Sensitive\",\n                [\"de\"] = \"Groß-/Kleinschreibung beachten\",\n                [\"es\"] = \"Sensible a Mayúsculas\",\n                [\"fr\"] = \"Sensible à la Casse\"\n            }\n        },\n        checkbox {\n            id = \"match_exactly\",\n            name = {\n                [\"en\"] = \"Match Exactly\",\n                [\"de\"] = \"Exakt übereinstimmen\",\n                [\"es\"] = \"Coincidir Exactamente\",\n                [\"fr\"] = \"Correspondance Exacte\"\n            }\n        },\n        checkbox {\n            id = \"invert\",\n            name = {\n                [\"en\"] = \"Invert\",\n                [\"de\"] = \"Invertieren\",\n                [\"es\"] = \"Invertir\",\n                [\"fr\"] = \"Inverser\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local filter_note = config and config.filter_note\n        local case_sensitive = config and config.case_sensitive or false\n        local match_exactly = config and config.match_exactly or false\n        local invert = config and config.invert or false\n\n        return function()\n            local data_point = source.dp()\n            local should_match = not invert\n            while data_point and (match(data_point, filter_note, case_sensitive, match_exactly) ~= should_match) do\n                data_point = source.dp()\n            end\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["filter-greater-than"]={
      script="-- Lua Function to filter data points by value (greater than threshold)\n-- Only passes through data points with values greater than a threshold\n\nlocal number = require(\"tng.config\").number\nlocal checkbox = require(\"tng.config\").checkbox\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-greater-than\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter Greater Than\",\n        [\"de\"] = \"Filtern größer als\",\n        [\"es\"] = \"Filtrar mayor que\",\n        [\"fr\"] = \"Filtrer supérieur à\",\n    },\n    description = {\n        [\"en\"] = [[Filters data points by value. Only data points with values greater than the threshold will pass through.\n\nConfiguration:\n• Threshold: The minimum value (exclusive by default)\n• Include Equal: Also include values equal to the threshold (default: false)]],\n        [\"de\"] = [[Filtert Datenpunkte nach Wert. Nur Datenpunkte mit Werten größer als der Schwellenwert werden durchgelassen.\n\nKonfiguration:\n• Schwellenwert: Der Mindestwert (standardmäßig exklusiv)\n• Gleich einschließen: Werte gleich dem Schwellenwert auch einschließen (Standard: false)]],\n        [\"es\"] = [[Filtra puntos de datos por valor. Solo los puntos de datos con valores mayores que el umbral pasarán.\n\nConfiguración:\n• Umbral: El valor mínimo (exclusivo por defecto)\n• Incluir igual: También incluir valores iguales al umbral (predeterminado: false)]],\n        [\"fr\"] = [[Filtre les points de données par valeur. Seuls les points de données avec des valeurs supérieures au seuil passeront.\n\nConfiguration:\n• Seuil: La valeur minimale (exclusive par défaut)\n• Inclure égal: Inclure également les valeurs égales au seuil (par défaut: false)]],\n    },\n    config = {\n        number {\n            id = \"threshold\",\n            name = {\n                [\"en\"] = \"Threshold\",\n                [\"de\"] = \"Schwellenwert\",\n                [\"es\"] = \"Umbral\",\n                [\"fr\"] = \"Seuil\",\n            },\n        },\n        checkbox {\n            id = \"include_equal\",\n            name = {\n                [\"en\"] = \"Include Equal\",\n                [\"de\"] = \"Gleich einschließen\",\n                [\"es\"] = \"Incluir igual\",\n                [\"fr\"] = \"Inclure égal\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local threshold = config and config.threshold or 0.0\n        local include_equal = config and config.include_equal or false\n\n        return function()\n            while true do\n                local data_point = source.dp()\n                if not data_point then\n                    return nil\n                end\n\n                local passes\n                if include_equal then\n                    passes = data_point.value >= threshold\n                else\n                    passes = data_point.value > threshold\n                end\n\n                if passes then\n                    return data_point\n                end\n            end\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["filter-less-than"]={
      script="-- Lua Function to filter data points by value (less than threshold)\n-- Only passes through data points with values less than a threshold\n\nlocal number = require(\"tng.config\").number\nlocal checkbox = require(\"tng.config\").checkbox\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-less-than\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter Less Than\",\n        [\"de\"] = \"Filtern kleiner als\",\n        [\"es\"] = \"Filtrar menor que\",\n        [\"fr\"] = \"Filtrer inférieur à\",\n    },\n    description = {\n        [\"en\"] = [[Filters data points by value. Only data points with values less than the threshold will pass through.\n\nConfiguration:\n• Threshold: The maximum value (exclusive by default)\n• Include Equal: Also include values equal to the threshold (default: false)]],\n        [\"de\"] = [[Filtert Datenpunkte nach Wert. Nur Datenpunkte mit Werten kleiner als der Schwellenwert werden durchgelassen.\n\nKonfiguration:\n• Schwellenwert: Der Maximalwert (standardmäßig exklusiv)\n• Gleich einschließen: Werte gleich dem Schwellenwert auch einschließen (Standard: false)]],\n        [\"es\"] = [[Filtra puntos de datos por valor. Solo los puntos de datos con valores menores que el umbral pasarán.\n\nConfiguración:\n• Umbral: El valor máximo (exclusivo por defecto)\n• Incluir igual: También incluir valores iguales al umbral (predeterminado: false)]],\n        [\"fr\"] = [[Filtre les points de données par valeur. Seuls les points de données avec des valeurs inférieures au seuil passeront.\n\nConfiguration:\n• Seuil: La valeur maximale (exclusive par défaut)\n• Inclure égal: Inclure également les valeurs égales au seuil (par défaut: false)]],\n    },\n    config = {\n        number {\n            id = \"threshold\",\n            name = {\n                [\"en\"] = \"Threshold\",\n                [\"de\"] = \"Schwellenwert\",\n                [\"es\"] = \"Umbral\",\n                [\"fr\"] = \"Seuil\",\n            },\n        },\n        checkbox {\n            id = \"include_equal\",\n            name = {\n                [\"en\"] = \"Include Equal\",\n                [\"de\"] = \"Gleich einschließen\",\n                [\"es\"] = \"Incluir igual\",\n                [\"fr\"] = \"Inclure égal\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local threshold = config and config.threshold or 0.0\n        local include_equal = config and config.include_equal or false\n\n        return function()\n            while true do\n                local data_point = source.dp()\n                if not data_point then\n                    return nil\n                end\n\n                local passes\n                if include_equal then\n                    passes = data_point.value <= threshold\n                else\n                    passes = data_point.value < threshold\n                end\n\n                if passes then\n                    return data_point\n                end\n            end\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    floor={
      script="-- Lua Function to floor values\n-- Rounds each data point's value down to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"floor\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Floor\",\n\9\9[\"de\"] = \"Abrunden\",\n\9\9[\"es\"] = \"Piso\",\n\9\9[\"fr\"] = \"Plancher\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[Rounds each data point's value down to the nearest multiple of a specified number.\n\nConfiguration:\n• Nearest: Round down to the nearest multiple of this number (default: 1.0)]],\n\9\9[\"de\"] = [[Rundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl ab.\n\nKonfiguration:\n• Nächste: Auf das nächste Vielfache dieser Zahl abrunden (Standard: 1.0)]],\n\9\9[\"es\"] = [[Redondea hacia abajo el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n• Más cercano: Redondear hacia abajo al múltiplo más cercano de este número (predeterminado: 1.0)]],\n\9\9[\"fr\"] = [[Arrondit vers le bas la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n• Plus proche: Arrondir vers le bas au multiple le plus proche de ce nombre (par défaut: 1.0)]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Floor to nearest multiple\n\9\9\9data_point.value = math.floor(data_point.value / nearest) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    multiply={
      script="-- Lua Function to multiply data point values by a configurable number\n-- This function multiplies all incoming data point values by a specified multiplier\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"multiply\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Multiply Values\",\n        [\"de\"] = \"Werte multiplizieren\",\n        [\"es\"] = \"Multiplicar Valores\",\n        [\"fr\"] = \"Multiplier les Valeurs\"\n    },\n    description = {\n        [\"en\"] = [[Multiplies all incoming data point values by a specified multiplier.\n\nConfiguration:\n• Multiplier: The number to multiply all values by (default: 1.0)]],\n        [\"de\"] = [[Multipliziert alle eingehenden Datenpunktwerte mit einem bestimmten Multiplikator.\n\nKonfiguration:\n• Multiplikator: Die Zahl, mit der alle Werte multipliziert werden (Standard: 1.0)]],\n        [\"es\"] = [[Multiplica todos los valores de puntos de datos entrantes por un multiplicador especificado.\n\nConfiguración:\n• Multiplicador: El número por el cual multiplicar todos los valores (predeterminado: 1.0)]],\n        [\"fr\"] = [[Multiplie toutes les valeurs de points de données entrantes par un multiplicateur spécifié.\n\nConfiguration:\n• Multiplicateur: Le nombre par lequel multiplier toutes les valeurs (par défaut: 1.0)]]\n    },\n    config = {\n        number {\n            id = \"multiplier\",\n            name = {\n                [\"en\"] = \"Multiplier\",\n                [\"de\"] = \"Multiplikator\",\n                [\"es\"] = \"Multiplicador\",\n                [\"fr\"] = \"Multiplicateur\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local multiplier = config and config.multiplier or 1.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value * multiplier\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["offset-value"]={
      script="-- Lua Function to offset data point values by a configurable number\n-- This function adds a constant offset to all incoming data point values\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"offset-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Offset Value\",\n        [\"de\"] = \"Wert verschieben\",\n        [\"es\"] = \"Desplazar Valor\",\n        [\"fr\"] = \"Décaler la Valeur\"\n    },\n    description = {\n        [\"en\"] = [[Adds a constant offset to all incoming data point values.\n\nConfiguration:\n• Offset: The number to add to all values (default: 0.0). Use negative values to subtract.]],\n        [\"de\"] = [[Fügt allen eingehenden Datenpunktwerten einen konstanten Offset hinzu.\n\nKonfiguration:\n• Offset: Die Zahl, die zu allen Werten addiert wird (Standard: 0.0). Verwenden Sie negative Werte zum Subtrahieren.]],\n        [\"es\"] = [[Añade un desplazamiento constante a todos los valores de puntos de datos entrantes.\n\nConfiguración:\n• Desplazamiento: El número a añadir a todos los valores (predeterminado: 0.0). Use valores negativos para restar.]],\n        [\"fr\"] = [[Ajoute un décalage constant à toutes les valeurs de points de données entrantes.\n\nConfiguration:\n• Décalage: Le nombre à ajouter à toutes les valeurs (par défaut: 0.0). Utilisez des valeurs négatives pour soustraire.]]\n    },\n    config = {\n        number {\n            id = \"offset\",\n            default = 0.0,\n            name = {\n                [\"en\"] = \"Offset\",\n                [\"de\"] = \"Offset\",\n                [\"es\"] = \"Desplazamiento\",\n                [\"fr\"] = \"Décalage\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local offset = config and config.offset or 0.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value + offset\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["override-label"]={
      script="-- Lua Function to override the label of all data points with a configurable string\n-- This function sets all incoming data point labels to a specified value\n\nlocal text = require(\"tng.config\").text\n\nreturn {\n    -- Configuration metadata\n    id = \"override-label\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Label\",\n        [\"de\"] = \"Label überschreiben\",\n        [\"es\"] = \"Sobrescribir Etiqueta\",\n        [\"fr\"] = \"Remplacer l'Étiquette\",\n    },\n    description = {\n        [\"en\"] = \"Sets all incoming data point labels to a specified value\",\n        [\"de\"] = \"Setzt alle eingehenden Datenpunkt-Labels auf einen bestimmten Wert\",\n        [\"es\"] = \"Establece todas las etiquetas de puntos de datos entrantes en un valor especificado\",\n        [\"fr\"] = \"Définit toutes les étiquettes de points de données entrantes sur une valeur spécifiée\",\n    },\n    config = {\n        text {\n            id = \"new_label\",\n            name = {\n                [\"en\"] = \"New Label\",\n                [\"de\"] = \"Neues Label\",\n                [\"es\"] = \"Nueva Etiqueta\",\n                [\"fr\"] = \"Nouvelle Étiquette\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_label = config and config.new_label\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_label then\n                return data_point\n            end\n            data_point.label = new_label\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["override-note"]={
      script="-- Lua Function to override the note of all data points with a configurable string\n-- This function sets all incoming data point notes to a specified value\n\nlocal text = require(\"tng.config\").text\n\nreturn {\n    -- Configuration metadata\n    id = \"override-note\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Note\",\n        [\"de\"] = \"Notiz überschreiben\",\n        [\"es\"] = \"Sobrescribir Nota\",\n        [\"fr\"] = \"Remplacer la Note\",\n    },\n    description = {\n        [\"en\"] = \"Sets all incoming data point notes to a specified value\",\n        [\"de\"] = \"Setzt alle eingehenden Datenpunkt-Notizen auf einen bestimmten Wert\",\n        [\"es\"] = \"Establece todas las notas de puntos de datos entrantes en un valor especificado\",\n        [\"fr\"] = \"Définit toutes les notes de points de données entrantes sur une valeur spécifiée\",\n    },\n    config = {\n        text {\n            id = \"new_note\",\n            name = {\n                [\"en\"] = \"New Note\",\n                [\"de\"] = \"Neue Notiz\",\n                [\"es\"] = \"Nueva Nota\",\n                [\"fr\"] = \"Nouvelle Note\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_note = config and config.new_note\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_note then\n                return data_point\n            end\n            data_point.note = new_note\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["override-value"]={
      script="-- Lua Function to override the value of all data points with a configurable number\n-- This function sets all incoming data point values to a specified value\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"override-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Value\",\n        [\"de\"] = \"Wert überschreiben\",\n        [\"es\"] = \"Sobrescribir Valor\",\n        [\"fr\"] = \"Remplacer la Valeur\",\n    },\n    description = {\n        [\"en\"] = \"Sets all incoming data point values to a specified value\",\n        [\"de\"] = \"Setzt alle eingehenden Datenpunktwerte auf einen bestimmten Wert\",\n        [\"es\"] = \"Establece todos los valores de puntos de datos entrantes en un valor especificado\",\n        [\"fr\"] = \"Définit toutes les valeurs de points de données entrantes sur une valeur spécifiée\",\n    },\n    config = {\n        number {\n            id = \"new_value\",\n            name = {\n                [\"en\"] = \"New Value\",\n                [\"de\"] = \"Neuer Wert\",\n                [\"es\"] = \"Nuevo Valor\",\n                [\"fr\"] = \"Nouvelle Valeur\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_value = config and config.new_value\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_value then\n                return data_point\n            end\n            data_point.value = new_value\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    round={
      script="-- Lua Function to round values\n-- Rounds each data point's value to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"round\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Round\",\n\9\9[\"de\"] = \"Runden\",\n\9\9[\"es\"] = \"Redondear\",\n\9\9[\"fr\"] = \"Arrondir\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[Rounds each data point's value to the nearest multiple of a specified number.\n\nConfiguration:\n• Nearest: Round to the nearest multiple of this number (default: 1.0)]],\n\9\9[\"de\"] = [[Rundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl.\n\nKonfiguration:\n• Nächste: Auf das nächste Vielfache dieser Zahl runden (Standard: 1.0)]],\n\9\9[\"es\"] = [[Redondea el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n• Más cercano: Redondear al múltiplo más cercano de este número (predeterminado: 1.0)]],\n\9\9[\"fr\"] = [[Arrondit la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n• Plus proche: Arrondir au multiple le plus proche de ce nombre (par défaut: 1.0)]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Round to nearest multiple\n\9\9\9data_point.value = math.floor((data_point.value / nearest) + 0.5) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["swap-label-note"]={
      script="-- Lua Function to swap label and note fields\n-- Swaps the label and note of each data point\n\nreturn {\n\9-- Configuration metadata\n\9id = \"swap-label-note\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_transform\"},\n\9title = {\n\9\9[\"en\"] = \"Swap Label and Note\",\n\9\9[\"de\"] = \"Label und Notiz tauschen\",\n\9\9[\"es\"] = \"Intercambiar etiqueta y nota\",\n\9\9[\"fr\"] = \"Échanger étiquette et note\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Swaps the label and note fields of each data point.\",\n\9\9[\"de\"] = \"Tauscht die Label- und Notizfelder jedes Datenpunkts aus.\",\n\9\9[\"es\"] = \"Intercambia los campos de etiqueta y nota de cada punto de datos.\",\n\9\9[\"fr\"] = \"Échange les champs étiquette et note de chaque point de données.\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Swap label and note\n\9\9\9local temp = data_point.label\n\9\9\9data_point.label = data_point.note\n\9\9\9data_point.note = temp\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["time-between"]={
      script="-- Lua Function to calculate time between data points\n-- Outputs the duration in seconds between each data point and the previous one\n\nlocal core = require(\"tng.core\")\nlocal checkbox = require(\"tng.config\").checkbox\n\nreturn {\n\9-- Configuration metadata\n\9id = \"time-between\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Time Between\",\n\9\9[\"de\"] = \"Zeit dazwischen\",\n\9\9[\"es\"] = \"Tiempo entre\",\n\9\9[\"fr\"] = \"Temps entre\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[Calculates the duration in seconds between each data point and the previous one. The output value is the time difference in seconds and can be treated as a duration.\n\nConfiguration:\n• Include Time to First: Include the time between now and the first data point (default: false)]],\n\9\9[\"de\"] = [[Berechnet die Dauer in Sekunden zwischen jedem Datenpunkt und dem vorherigen. Der Ausgabewert ist die Zeitdifferenz in Sekunden und kann als Dauer behandelt werden.\n\nKonfiguration:\n• Zeit zum Ersten einschließen: Die Zeit zwischen jetzt und dem ersten Datenpunkt einschließen (Standard: false)]],\n\9\9[\"es\"] = [[Calcula la duración en segundos entre cada punto de datos y el anterior. El valor de salida es la diferencia de tiempo en segundos y puede tratarse como una duración.\n\nConfiguración:\n• Incluir tiempo al primero: Incluir el tiempo entre ahora y el primer punto de datos (predeterminado: false)]],\n\9\9[\"fr\"] = [[Calcule la durée en secondes entre chaque point de données et le précédent. La valeur de sortie est la différence de temps en secondes et peut être traitée comme une durée.\n\nConfiguration:\n• Inclure le temps jusqu'au premier: Inclure le temps entre maintenant et le premier point de données (par défaut: false)]],\n\9},\n\9config = {\n\9\9checkbox {\n\9\9\9id = \"include_first\",\n\9\9\9default = false,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Include Time to First\",\n\9\9\9\9[\"de\"] = \"Zeit zum Ersten einschließen\",\n\9\9\9\9[\"es\"] = \"Incluir tiempo al primero\",\n\9\9\9\9[\"fr\"] = \"Inclure le temps jusqu'au premier\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local include_first = config and config.include_first or false\n\9\9local previous_point = nil\n\n\9\9return function()\n\9\9\9-- Initialize on first call\n\9\9\9if previous_point == nil then\n\9\9\9\9local first_point = source.dp()\n\9\9\9\9if not first_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\n\9\9\9\9previous_point = first_point\n\n\9\9\9\9if include_first then\n\9\9\9\9\9-- Return synthetic point with time from now to first\n\9\9\9\9\9local now = core.time().timestamp\n\9\9\9\9\9local duration_seconds = (now - first_point.timestamp) / 1000.0\n\n\9\9\9\9\9return {\n\9\9\9\9\9\9timestamp = first_point.timestamp,\n\9\9\9\9\9\9offset = first_point.offset,\n\9\9\9\9\9\9value = duration_seconds,\n\9\9\9\9\9\9label = \"\",\n\9\9\9\9\9\9note = \"\",\n\9\9\9\9\9}\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9-- Get next data point\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Calculate duration from previous to current\n\9\9\9local duration_seconds = (previous_point.timestamp - data_point.timestamp) / 1000.0\n\n\9\9\9-- Create output point using previous point's identity\n\9\9\9local output_point = {\n\9\9\9\9timestamp = previous_point.timestamp,\n\9\9\9\9offset = previous_point.offset,\n\9\9\9\9value = duration_seconds,\n\9\9\9\9label = previous_point.label,\n\9\9\9\9note = previous_point.note,\n\9\9\9}\n\n\9\9\9-- Update state for next iteration\n\9\9\9previous_point = data_point\n\n\9\9\9return output_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-difference"]={
      script="-- Lua Function to calculate value differences\n-- Outputs the difference between each data point's value and the next one\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-difference\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\", \"_transform\"},\n\9title = {\n\9\9[\"en\"] = \"Value Difference\",\n\9\9[\"de\"] = \"Wertdifferenz\",\n\9\9[\"es\"] = \"Diferencia de valor\",\n\9\9[\"fr\"] = \"Différence de valeur\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Calculates the difference between each data point's value and the next one. Each output point has its original identity with the value set to the difference.\",\n\9\9[\"de\"] = \"Berechnet die Differenz zwischen dem Wert jedes Datenpunkts und dem nächsten. Jeder Ausgabepunkt hat seine ursprüngliche Identität mit dem Wert auf die Differenz gesetzt.\",\n\9\9[\"es\"] = \"Calcula la diferencia entre el valor de cada punto de datos y el siguiente. Cada punto de salida tiene su identidad original con el valor establecido en la diferencia.\",\n\9\9[\"fr\"] = \"Calcule la différence entre la valeur de chaque point de données et la suivante. Chaque point de sortie a son identité d'origine avec la valeur définie sur la différence.\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9local next_point = nil\n\n\9\9return function()\n\9\9\9-- Pre-load the next point on first call\n\9\9\9if next_point == nil then\n\9\9\9\9next_point = source.dp()\n\9\9\9\9if not next_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9-- Current point is what we'll output\n\9\9\9local current_point = next_point\n\n\9\9\9-- Pre-load the next point for the next iteration\n\9\9\9next_point = source.dp()\n\9\9\9if not next_point then\n\9\9\9\9-- No more points, can't calculate difference\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Calculate difference (current - next)\n\9\9\9local difference = current_point.value - next_point.value\n\n\9\9\9-- Return current point with difference as value\n\9\9\9return {\n\9\9\9\9timestamp = current_point.timestamp,\n\9\9\9\9offset = current_point.offset,\n\9\9\9\9value = difference,\n\9\9\9\9label = current_point.label,\n\9\9\9\9note = current_point.note,\n\9\9\9}\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-day-of-month"]={
      script="-- Lua Function to set value to day of month\n-- Sets each data point's value to its day of the month (1-31)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-day-of-month\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Day of Month\",\n\9\9[\"de\"] = \"Wert zu Tag des Monats\",\n\9\9[\"es\"] = \"Valor a día del mes\",\n\9\9[\"fr\"] = \"Valeur au jour du mois\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to its day of the month (1-31).\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf seinen Tag des Monats (1-31).\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en su día del mes (1-31).\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur son jour du mois (1-31).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.day\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-day-of-week"]={
      script="-- Lua Function to set value to day of week\n-- Sets each data point's value to its day of the week (1-7, Monday is 1)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-day-of-week\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Day of Week\",\n\9\9[\"de\"] = \"Wert zu Wochentag\",\n\9\9[\"es\"] = \"Valor a día de la semana\",\n\9\9[\"fr\"] = \"Valeur au jour de la semaine\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to its day of the week (1-7, where Monday is 1 and Sunday is 7).\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf seinen Wochentag (1-7, wobei Montag 1 und Sonntag 7 ist).\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en su día de la semana (1-7, donde lunes es 1 y domingo es 7).\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur son jour de la semaine (1-7, où lundi est 1 et dimanche est 7).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Get the date from the timestamp\n\9\9\9local date = core.date(data_point)\n\n\9\9\9-- Set value to day of week\n\9\9\9data_point.value = date.wday\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-hour-of-day"]={
      script="-- Lua Function to set value to hour of day\n-- Sets each data point's value to its hour of the day (0-23)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-hour-of-day\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Hour (0-23)\",\n\9\9[\"de\"] = \"Wert zu Stunde (0-23)\",\n\9\9[\"es\"] = \"Valor a hora (0-23)\",\n\9\9[\"fr\"] = \"Valeur à l'heure (0-23)\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to its hour of the day (0-23).\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf seine Stunde des Tages (0-23).\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en su hora del día (0-23).\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur son heure du jour (0-23).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.hour or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-minute-of-hour"]={
      script="-- Lua Function to set value to minute of hour\n-- Sets each data point's value to its minute of the hour (0-59)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-minute-of-hour\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Minute of Hour\",\n\9\9[\"de\"] = \"Wert zu Minute der Stunde\",\n\9\9[\"es\"] = \"Valor a minuto de la hora\",\n\9\9[\"fr\"] = \"Valeur à la minute de l'heure\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to its minute of the hour (0-59).\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf seine Minute der Stunde (0-59).\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en su minuto de la hora (0-59).\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur sa minute de l'heure (0-59).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.min or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-month-of-year"]={
      script="-- Lua Function to set value to month of year\n-- Sets each data point's value to its month of the year (1-12)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-month-of-year\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Month of Year\",\n\9\9[\"de\"] = \"Wert zu Monat des Jahres\",\n\9\9[\"es\"] = \"Valor a mes del año\",\n\9\9[\"fr\"] = \"Valeur au mois de l'année\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to its month of the year (1-12, where January is 1).\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf seinen Monat des Jahres (1-12, wobei Januar 1 ist).\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en su mes del año (1-12, donde enero es 1).\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur son mois de l'année (1-12, où janvier est 1).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.month\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-second-of-minute"]={
      script="-- Lua Function to set value to second of minute\n-- Sets each data point's value to its second of the minute (0-59)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-second-of-minute\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Second of Minute\",\n\9\9[\"de\"] = \"Wert zu Sekunde der Minute\",\n\9\9[\"es\"] = \"Valor a segundo del minuto\",\n\9\9[\"fr\"] = \"Valeur à la seconde de la minute\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to its second of the minute (0-59).\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf seine Sekunde der Minute (0-59).\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en su segundo del minuto (0-59).\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur sa seconde de la minute (0-59).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.sec or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-time-of-day"]={
      script="-- Lua Function to set value to time of day\n-- Sets each data point's value to the time of day in seconds since midnight\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-time-of-day\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Time of Day\",\n\9\9[\"de\"] = \"Wert zu Tageszeit\",\n\9\9[\"es\"] = \"Valor a hora del día\",\n\9\9[\"fr\"] = \"Valeur à l'heure de la journée\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to the time of day in seconds since midnight. The output is a duration value representing elapsed time since the start of the day.\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf die Tageszeit in Sekunden seit Mitternacht. Die Ausgabe ist ein Dauerwert, der die verstrichene Zeit seit Tagesbeginn darstellt.\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en la hora del día en segundos desde la medianoche. La salida es un valor de duración que representa el tiempo transcurrido desde el comienzo del día.\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur l'heure de la journée en secondes depuis minuit. La sortie est une valeur de durée représentant le temps écoulé depuis le début de la journée.\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Get the date from the data point\n\9\9\9local date = core.date(data_point)\n\n\9\9\9-- Calculate seconds since midnight\n\9\9\9local seconds_since_midnight = (date.hour or 0) * 3600 + (date.min or 0) * 60 + (date.sec or 0)\n\n\9\9\9-- Set value to time of day in seconds\n\9\9\9data_point.value = seconds_since_midnight\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-year"]={
      script="-- Lua Function to set value to year\n-- Sets each data point's value to its year\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-year\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Year\",\n\9\9[\"de\"] = \"Wert zu Jahr\",\n\9\9[\"es\"] = \"Valor a año\",\n\9\9[\"fr\"] = \"Valeur à l'année\",\n\9},\n\9description = {\n\9\9[\"en\"] = \"Sets each data point's value to its year (e.g., 2025).\",\n\9\9[\"de\"] = \"Setzt den Wert jedes Datenpunkts auf sein Jahr (z.B. 2025).\",\n\9\9[\"es\"] = \"Establece el valor de cada punto de datos en su año (p. ej., 2025).\",\n\9\9[\"fr\"] = \"Définit la valeur de chaque point de données sur son année (par exemple, 2025).\",\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.year\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    }
  },
  published_at="2025-10-19T15:12:37Z",
  translations={
    _all_fields={
      de="Alle Felder",
      en="All Fields",
      es="Todos los campos",
      fr="Tous les champs"
    },
    _arithmetic={
      de="Arithmetik",
      en="Arithmetic",
      es="Aritmética",
      fr="Arithmétique"
    },
    _compare_by={
      de="Vergleichen nach",
      en="Compare By",
      es="Comparar por",
      fr="Comparer par"
    },
    _days={
      de="Tage",
      en="Days",
      es="Días",
      fr="Jours"
    },
    _filter={
      de="Filter",
      en="Filter",
      es="Filtro",
      fr="Filtre"
    },
    _hours={
      de="Stunden",
      en="Hours",
      es="Horas",
      fr="Heures"
    },
    _label_and_note={
      de="Label und Notiz",
      en="Label and Note",
      es="Etiqueta y nota",
      fr="Étiquette et note"
    },
    _label_only={
      de="Nur Label",
      en="Label Only",
      es="Solo etiqueta",
      fr="Étiquette uniquement"
    },
    _minutes={
      de="Minuten",
      en="Minutes",
      es="Minutos",
      fr="Minutes"
    },
    _months={
      de="Monate",
      en="Months",
      es="Meses",
      fr="Mois"
    },
    _note_only={
      de="Nur Notiz",
      en="Note Only",
      es="Solo nota",
      fr="Note uniquement"
    },
    _seconds={
      de="Sekunden",
      en="Seconds",
      es="Segundos",
      fr="Secondes"
    },
    _time={
      de="Zeit",
      en="Time",
      es="Tiempo",
      fr="Temps"
    },
    _transform={
      de="Transformieren",
      en="Transform",
      es="Transformar",
      fr="Transformer"
    },
    _value_and_label={
      de="Wert und Label",
      en="Value and Label",
      es="Valor y etiqueta",
      fr="Valeur et étiquette"
    },
    _value_and_note={
      de="Wert und Notiz",
      en="Value and Note",
      es="Valor y nota",
      fr="Valeur et note"
    },
    _value_only={
      de="Nur Wert",
      en="Value Only",
      es="Solo valor",
      fr="Valeur uniquement"
    },
    _weeks={
      de="Wochen",
      en="Weeks",
      es="Semanas",
      fr="Semaines"
    },
    _years={
      de="Jahre",
      en="Years",
      es="Años",
      fr="Années"
    }
  }
}
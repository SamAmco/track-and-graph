return {
  functions={
    ["a1-test"]={
      script="-- Example function demonstrating all available configuration types\n-- This function showcases text, number, checkbox, enum, uint, duration, localtime, and instant inputs\n\nlocal tng_config = require(\"tng.config\")\nlocal core = require(\"tng.core\")\nlocal text = tng_config.text\nlocal number = tng_config.number\nlocal checkbox = tng_config.checkbox\nlocal enum = tng_config.enum\nlocal uint = tng_config.uint\nlocal duration = tng_config.duration\nlocal localtime = tng_config.localtime\nlocal instant = tng_config.instant\n\nlocal now = core.time()\nlocal default_instant = now and now.timestamp -- Current time as epoch milliseconds\n\nreturn {\n\9id = \"a1-test\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = { \"_transform\" },\n\9title = {\n\9\9[\"en\"] = \"Configuration Types Demo\",\n\9\9[\"de\"] = \"Konfigurationstypen-Demo\",\n\9\9[\"es\"] = \"Demostración de tipos de configuración\",\n\9\9[\"fr\"] = \"Démonstration des types de configuration\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nDemonstrates all available configuration input types: text, number, checkbox, enum, uint, duration, localtime, and instant. This function passes through all data points unchanged.\n]],\n\9\9[\"de\"] = [[\nDemonstriert alle verfügbaren Konfigurationseingabetypen: Text, Nummer, Kontrollkästchen, Aufzählung, uint, Dauer, Ortszeit und Zeitpunkt. Diese Funktion gibt alle Datenpunkte unverändert weiter.\n]],\n\9\9[\"es\"] = [[\nDemuestra todos los tipos de entrada de configuración disponibles: texto, número, casilla de verificación, enumeración, uint, duración, hora local e instante. Esta función pasa todos los puntos de datos sin cambios.\n]],\n\9\9[\"fr\"] = [[\nDémontre tous les types d'entrée de configuration disponibles : texte, nombre, case à cocher, énumération, uint, durée, heure locale et instant. Cette fonction transmet tous les points de données inchangés.\n]],\n\9},\n\9config = {\n\9\9text {\n\9\9\9id = \"text_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Text Input\",\n\9\9\9\9[\"de\"] = \"Texteingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de texto\",\n\9\9\9\9[\"fr\"] = \"Saisie de texte\",\n\9\9\9},\n\9\9\9default = \"Example text\",\n\9\9},\n\9\9number {\n\9\9\9id = \"number_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Number Input\",\n\9\9\9\9[\"de\"] = \"Zahleneingabe\",\n\9\9\9\9[\"es\"] = \"Entrada numérica\",\n\9\9\9\9[\"fr\"] = \"Saisie numérique\",\n\9\9\9},\n\9\9\9default = 3.14,\n\9\9},\n\9\9checkbox {\n\9\9\9id = \"checkbox_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Checkbox Input\",\n\9\9\9\9[\"de\"] = \"Kontrollkästchen\",\n\9\9\9\9[\"es\"] = \"Casilla de verificación\",\n\9\9\9\9[\"fr\"] = \"Case à cocher\",\n\9\9\9},\n\9\9\9default = true,\n\9\9},\n\9\9enum {\n\9\9\9id = \"enum_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Enum Input\",\n\9\9\9\9[\"de\"] = \"Aufzählungseingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de enumeración\",\n\9\9\9\9[\"fr\"] = \"Saisie d'énumération\",\n\9\9\9},\n\9\9\9options = { \"_hours\", \"_days\", \"_weeks\" },\n\9\9\9default = \"_days\",\n\9\9},\n\9\9uint {\n\9\9\9id = \"uint_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Unsigned Integer Input\",\n\9\9\9\9[\"de\"] = \"Vorzeichenlose Ganzzahleingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de entero sin signo\",\n\9\9\9\9[\"fr\"] = \"Saisie d'entier non signé\",\n\9\9\9},\n\9\9\9default = 42,\n\9\9},\n\9\9duration {\n\9\9\9id = \"duration_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Duration Input\",\n\9\9\9\9[\"de\"] = \"Dauereingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de duración\",\n\9\9\9\9[\"fr\"] = \"Saisie de durée\",\n\9\9\9},\n\9\9\9default = 3600000, -- 1 hour (DURATION.HOUR)\n\9\9},\n\9\9localtime {\n\9\9\9id = \"localtime_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Time of Day Input\",\n\9\9\9\9[\"de\"] = \"Tageszeiteingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de hora del día\",\n\9\9\9\9[\"fr\"] = \"Saisie de l'heure de la journée\",\n\9\9\9},\n\9\9\9default = 52200000, -- 14:30 (2:30 PM) = 14.5 hours * DURATION.HOUR\n\9\9},\n\9\9instant {\n\9\9\9id = \"instant_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Date & Time Input\",\n\9\9\9\9[\"de\"] = \"Datum & Uhrzeit-Eingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de fecha y hora\",\n\9\9\9\9[\"fr\"] = \"Saisie de date et heure\",\n\9\9\9},\n\9\9\9default = default_instant, -- Current time as epoch milliseconds\n\9\9},\n\9},\n\n\9generator = function(source, config)\n\9\9-- Access configuration values (not used in this demo)\n\9\9local text_val = config and config.text_example\n\9\9local number_val = config and config.number_example\n\9\9local checkbox_val = config and config.checkbox_example\n\9\9local enum_val = config and config.enum_example\n\9\9local uint_val = config and config.uint_example\n\9\9local duration_val = config and config.duration_example\n\9\9local localtime_val = config and config.localtime_example\n\9\9local instant_val = config and config.instant_example\n\n\9\9-- Pass through all data points unchanged\n\9\9return function()\n\9\9\9local dp = source.dp()\n\9\9\9if not dp then\n\9\9\9\9return nil\n\9\9\9end\n\9\9\9dp.timestamp = instant_val or dp.timestamp\n\9\9\9return dp\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["absolute-value"]={
      script="-- Lua Function to take absolute value\n-- Converts all data point values to their absolute value\n\nreturn {\n\9-- Configuration metadata\n\9id = \"absolute-value\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Absolute Value\",\n\9\9[\"de\"] = \"Absolutwert\",\n\9\9[\"es\"] = \"Valor absoluto\",\n\9\9[\"fr\"] = \"Valeur absolue\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nConverts each data point's value to its absolute value (removes negative sign).\n]],\n\9\9[\"de\"] = [[\nKonvertiert den Wert jedes Datenpunkts zu seinem Absolutwert (entfernt negatives Vorzeichen).\n]],\n\9\9[\"es\"] = [[\nConvierte el valor de cada punto de datos a su valor absoluto (elimina el signo negativo).\n]],\n\9\9[\"fr\"] = [[\nConvertit la valeur de chaque point de données en sa valeur absolue (supprime le signe négatif).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Convert to absolute value\n\9\9\9data_point.value = math.abs(data_point.value)\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ceil={
      script="-- Lua Function to ceiling values\n-- Rounds each data point's value up to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"ceil\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Ceiling\",\n\9\9[\"de\"] = \"Aufrunden\",\n\9\9[\"es\"] = \"Techo\",\n\9\9[\"fr\"] = \"Plafond\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nRounds each data point's value up to the nearest multiple of a specified number.\n\nConfiguration:\n- **Nearest**: Round up to the nearest multiple of this number (default: 1.0)\n]],\n\9\9[\"de\"] = [[\nRundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl auf.\n\nKonfiguration:\n- **Nächste**: Auf das nächste Vielfache dieser Zahl aufrunden (Standard: 1.0)\n]],\n\9\9[\"es\"] = [[\nRedondea hacia arriba el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n- **Más cercano**: Redondear hacia arriba al múltiplo más cercano de este número (predeterminado: 1.0)\n]],\n\9\9[\"fr\"] = [[\nArrondit vers le haut la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n- **Plus proche**: Arrondir vers le haut au multiple le plus proche de ce nombre (par défaut: 1.0)\n]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Ceiling to nearest multiple\n\9\9\9data_point.value = math.ceil(data_point.value / nearest) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["distinct-until-changed"]={
      script="-- Lua Function to filter out consecutive duplicates based on selected fields\n-- Only passes through data points when the selected fields change from the previous one\n\nlocal enum = require(\"tng.config\").enum\n\nreturn {\n\9-- Configuration metadata\n\9id = \"distinct-until-changed\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = { \"_filter\" },\n\9title = {\n\9\9[\"en\"] = \"Distinct Until Changed\",\n\9\9[\"de\"] = \"Eindeutig bis geändert\",\n\9\9[\"es\"] = \"Distinto hasta cambio\",\n\9\9[\"fr\"] = \"Distinct jusqu'au changement\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nFilters out consecutive duplicates based on the selected fields. Only data points where the selected fields differ from the previous one will pass through.\n\n- **All Fields** - Compare value, label, and note\n- **Value Only** - Compare value only\n- **Label Only** - Compare label only\n- **Note Only** - Compare note only\n- **Value and Label** - Compare value and label\n- **Value and Note** - Compare value and note\n- **Label and Note** - Compare label and note\n]],\n\9\9[\"de\"] = [[\nFiltert aufeinanderfolgende Duplikate basierend auf den ausgewählten Feldern heraus. Nur Datenpunkte, bei denen sich die ausgewählten Felder vom vorherigen unterscheiden, werden durchgelassen.\n\n- **Alle Felder** - Vergleicht Wert, Label und Notiz\n- **Nur Wert** - Vergleicht nur Wert\n- **Nur Label** - Vergleicht nur Label\n- **Nur Notiz** - Vergleicht nur Notiz\n- **Wert und Label** - Vergleicht Wert und Label\n- **Wert und Notiz** - Vergleicht Wert und Notiz\n- **Label und Notiz** - Vergleicht Label und Notiz\n]],\n\9\9[\"es\"] = [[\nFiltra duplicados consecutivos basándose en los campos seleccionados. Solo los puntos de datos donde los campos seleccionados difieren del anterior pasarán.\n\n- **Todos los campos** - Compara valor, etiqueta y nota\n- **Solo valor** - Compara solo valor\n- **Solo etiqueta** - Compara solo etiqueta\n- **Solo nota** - Compara solo nota\n- **Valor y etiqueta** - Compara valor y etiqueta\n- **Valor y nota** - Compara valor y nota\n- **Etiqueta y nota** - Compara etiqueta y nota\n]],\n\9\9[\"fr\"] = [[\nFiltre les doublons consécutifs en fonction des champs sélectionnés. Seuls les points de données où les champs sélectionnés diffèrent du précédent passeront.\n\n- **Tous les champs** - Compare valeur, étiquette et note\n- **Valeur uniquement** - Compare la valeur uniquement\n- **Étiquette uniquement** - Compare l'étiquette uniquement\n- **Note uniquement** - Compare la note uniquement\n- **Valeur et étiquette** - Compare valeur et étiquette\n- **Valeur et note** - Compare valeur et note\n- **Étiquette et note** - Compare étiquette et note\n]],\n\9},\n\9config = {\n\9\9enum {\n\9\9\9id = \"compare_by\",\n\9\9\9name = \"_compare_by\",\n\9\9\9options = {\n\9\9\9\9\"_all_fields\",\n\9\9\9\9\"_value_only\",\n\9\9\9\9\"_label_only\",\n\9\9\9\9\"_note_only\",\n\9\9\9\9\"_value_and_label\",\n\9\9\9\9\"_value_and_note\",\n\9\9\9\9\"_label_and_note\",\n\9\9\9},\n\9\9\9default = \"_all_fields\",\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local compare_by = config and config.compare_by or \"_all_fields\"\n\n\9\9local last_value = nil\n\9\9local last_label = nil\n\9\9local last_note = nil\n\n\9\9return function()\n\9\9\9while true do\n\9\9\9\9local data_point = source.dp()\n\9\9\9\9if not data_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\n\9\9\9\9local current_value = data_point.value\n\9\9\9\9local current_label = data_point.label\n\9\9\9\9local current_note = data_point.note\n\n\9\9\9\9local is_different = false\n\n\9\9\9\9if compare_by == \"_all_fields\" then\n\9\9\9\9\9is_different = (current_value ~= last_value)\n\9\9\9\9\9\9or (current_label ~= last_label)\n\9\9\9\9\9\9or (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_value_only\" then\n\9\9\9\9\9is_different = (current_value ~= last_value)\n\9\9\9\9elseif compare_by == \"_label_only\" then\n\9\9\9\9\9is_different = (current_label ~= last_label)\n\9\9\9\9elseif compare_by == \"_note_only\" then\n\9\9\9\9\9is_different = (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_value_and_label\" then\n\9\9\9\9\9is_different = (current_value ~= last_value) or (current_label ~= last_label)\n\9\9\9\9elseif compare_by == \"_value_and_note\" then\n\9\9\9\9\9is_different = (current_value ~= last_value) or (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_label_and_note\" then\n\9\9\9\9\9is_different = (current_label ~= last_label) or (current_note ~= last_note)\n\9\9\9\9end\n\n\9\9\9\9if is_different then\n\9\9\9\9\9last_value = current_value\n\9\9\9\9\9last_label = current_label\n\9\9\9\9\9last_note = current_note\n\9\9\9\9\9return data_point\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    divide={
      script="-- Lua Function to divide data point values by a configurable number\n-- This function divides all incoming data point values by a specified divisor\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"divide\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Divide Values\",\n        [\"de\"] = \"Werte dividieren\",\n        [\"es\"] = \"Dividir Valores\",\n        [\"fr\"] = \"Diviser les Valeurs\"\n    },\n    description = {\n        [\"en\"] = [[\nDivides all incoming data point values by a specified divisor.\n\nConfiguration:\n- **Divisor**: The number to divide all values by (default: 1.0)\n]],\n        [\"de\"] = [[\nDividiert alle eingehenden Datenpunktwerte durch einen bestimmten Divisor.\n\nKonfiguration:\n- **Divisor**: Die Zahl, durch die alle Werte dividiert werden (Standard: 1.0)\n]],\n        [\"es\"] = [[\nDivide todos los valores de puntos de datos entrantes por un divisor especificado.\n\nConfiguración:\n- **Divisor**: El número por el cual dividir todos los valores (predeterminado: 1.0)\n]],\n        [\"fr\"] = [[\nDivise toutes les valeurs de points de données entrantes par un diviseur spécifié.\n\nConfiguration:\n- **Diviseur**: Le nombre par lequel diviser toutes les valeurs (par défaut: 1.0)\n]]\n    },\n    config = {\n        number {\n            id = \"divisor\",\n            default = 1.0,\n            name = {\n                [\"en\"] = \"Divisor\",\n                [\"de\"] = \"Divisor\",\n                [\"es\"] = \"Divisor\",\n                [\"fr\"] = \"Diviseur\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local divisor = config and config.divisor or 1.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value / divisor\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["filter-after-first"]={
      script="-- Lua Function to filter data points after a reference point\n-- Outputs all data points from the first source that come after the first point in the second source\n\nreturn {\n\9-- Configuration metadata\n\9id = \"filter-after-first\",\n\9version = \"1.0.0\",\n\9inputCount = 2,\n\9categories = {\"_filter\"},\n\9title = {\n\9\9[\"en\"] = \"Filter After First\",\n\9\9[\"de\"] = \"Filtern nach Erstem\",\n\9\9[\"es\"] = \"Filtrar después del primero\",\n\9\9[\"fr\"] = \"Filtrer après le premier\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nFilters data points from the first input source to only include those that occur after the first data point in the second input source.\n\nThis is useful for filtering data based on a reference event or timestamp from another tracker.\n]],\n\9\9[\"de\"] = [[\nFiltert Datenpunkte aus der ersten Eingabequelle, um nur diejenigen einzuschließen, die nach dem ersten Datenpunkt in der zweiten Eingabequelle auftreten.\n\nDies ist nützlich zum Filtern von Daten basierend auf einem Referenzereignis oder Zeitstempel von einem anderen Tracker.\n]],\n\9\9[\"es\"] = [[\nFiltra puntos de datos de la primera fuente de entrada para incluir solo aquellos que ocurren después del primer punto de datos en la segunda fuente de entrada.\n\nEsto es útil para filtrar datos basados en un evento de referencia o marca de tiempo de otro rastreador.\n]],\n\9\9[\"fr\"] = [[\nFiltre les points de données de la première source d'entrée pour n'inclure que ceux qui se produisent après le premier point de données de la deuxième source d'entrée.\n\nCeci est utile pour filtrer les données basées sur un événement de référence ou un horodatage d'un autre tracker.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(sources, config)\n\9\9local source1 = sources[1]\n\9\9local source2 = sources[2]\n\9\9local cutoff_timestamp = nil\n\n\9\9return function()\n\9\9\9-- Initialize cutoff on first call\n\9\9\9if cutoff_timestamp == nil then\n\9\9\9\9local reference_point = source2.dp()\n\9\9\9\9cutoff_timestamp = reference_point and reference_point.timestamp\n\9\9\9end\n\n\9\9\9-- Get next point from source1 and check if it's after cutoff\n\9\9\9local data_point = source1.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Data points are in reverse chronological order, so \"after\" means greater timestamp\n\9\9\9if not cutoff_timestamp or data_point.timestamp > cutoff_timestamp then\n\9\9\9\9return data_point\n\9\9\9end\n\n\9\9\9-- If the data point is not after the cutoff we're done\n\9\9\9return nil\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["filter-by-label"]={
      script="-- Example Lua Function with Input Count and Configuration\n-- This function filters data points by label\n\nlocal tng_config = require(\"tng.config\")\nlocal text = tng_config.text\nlocal checkbox = tng_config.checkbox\n\nlocal function match(data_point, filter_label, case_sensitive, match_exactly)\n    if filter_label == nil then\n        return true\n    end\n\n    local data_label = data_point.label\n    if not data_label then return false end\n\n    -- Apply case sensitivity\n    if not case_sensitive then\n        data_label = string.lower(data_label)\n        filter_label = string.lower(filter_label)\n    end\n\n    -- Apply matching mode\n    if match_exactly then\n        return data_label == filter_label\n    else\n        return string.find(data_label, filter_label, 1, true) ~= nil\n    end\nend\n\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-by-label\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter by Label\",\n        [\"de\"] = \"Filtern nach Etikett\",\n        [\"es\"] = \"Filtrar por Etiqueta\",\n        [\"fr\"] = \"Filtrer par Étiquette\"\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by their label field. Only data points matching the filter criteria will pass through.\n\nConfiguration:\n- **Filter Label**: The text to search for in labels\n- **Case Sensitive**: Match case exactly (default: false)\n- **Match Exactly**: Require exact match instead of substring (default: false)\n- **Invert**: Keep data points that DON'T match instead (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach ihrem Label-Feld. Nur Datenpunkte, die den Filterkriterien entsprechen, werden durchgelassen.\n\nKonfiguration:\n- **Filter-Label**: Der Text, nach dem in Labels gesucht werden soll\n- **Groß-/Kleinschreibung beachten**: Groß-/Kleinschreibung exakt beachten (Standard: false)\n- **Exakt übereinstimmen**: Exakte Übereinstimmung statt Teilstring erforderlich (Standard: false)\n- **Invertieren**: Datenpunkte behalten, die NICHT übereinstimmen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por su campo de etiqueta. Solo los puntos de datos que coincidan con los criterios del filtro pasarán.\n\nConfiguración:\n- **Filtrar Etiqueta**: El texto a buscar en las etiquetas\n- **Sensible a Mayúsculas**: Coincidir exactamente con mayúsculas y minúsculas (predeterminado: false)\n- **Coincidir Exactamente**: Requerir coincidencia exacta en lugar de subcadena (predeterminado: false)\n- **Invertir**: Mantener puntos de datos que NO coincidan (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par leur champ d'étiquette. Seuls les points de données correspondant aux critères du filtre passeront.\n\nConfiguration:\n- **Filtrer l'Étiquette**: Le texte à rechercher dans les étiquettes\n- **Sensible à la Casse**: Correspondance exacte de la casse (par défaut: false)\n- **Correspondance Exacte**: Nécessite une correspondance exacte au lieu d'une sous-chaîne (par défaut: false)\n- **Inverser**: Conserver les points de données qui NE correspondent PAS (par défaut: false)\n]]\n    },\n    config = {\n        text {\n            id = \"filter_label\",\n            name = {\n                [\"en\"] = \"Filter Label\",\n                [\"de\"] = \"Filter-Label\",\n                [\"es\"] = \"Filtrar Etiqueta\",\n                [\"fr\"] = \"Filtrer l'Étiquette\"\n            }\n        },\n        checkbox {\n            id = \"case_sensitive\",\n            name = {\n                [\"en\"] = \"Case Sensitive\",\n                [\"de\"] = \"Groß-/Kleinschreibung beachten\",\n                [\"es\"] = \"Sensible a Mayúsculas\",\n                [\"fr\"] = \"Sensible à la Casse\"\n            }\n        },\n        checkbox {\n            id = \"match_exactly\",\n            name = {\n                [\"en\"] = \"Match Exactly\",\n                [\"de\"] = \"Exakt übereinstimmen\",\n                [\"es\"] = \"Coincidir Exactamente\",\n                [\"fr\"] = \"Correspondance Exacte\"\n            }\n        },\n        checkbox {\n            id = \"invert\",\n            name = {\n                [\"en\"] = \"Invert\",\n                [\"de\"] = \"Invertieren\",\n                [\"es\"] = \"Invertir\",\n                [\"fr\"] = \"Inverser\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local filter_label = config and config.filter_label\n        local case_sensitive = config and config.case_sensitive or false\n        local match_exactly = config and config.match_exactly or false\n        local invert = config and config.invert or false\n\n        return function()\n            local data_point = source.dp()\n            local should_match = not invert\n            while data_point and (match(data_point, filter_label, case_sensitive, match_exactly) ~= should_match) do\n                data_point = source.dp()\n            end\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["filter-by-note"]={
      script="-- Lua Function to filter data points by note\n-- This function filters data points by note\n\nlocal tng_config = require(\"tng.config\")\nlocal text = tng_config.text\nlocal checkbox = tng_config.checkbox\n\nlocal function match(data_point, filter_note, case_sensitive, match_exactly)\n    if filter_note == nil then\n        return true\n    end\n\n    local data_note = data_point.note\n    if not data_note then return false end\n\n    -- Apply case sensitivity\n    if not case_sensitive then\n        data_note = string.lower(data_note)\n        filter_note = string.lower(filter_note)\n    end\n\n    -- Apply matching mode\n    if match_exactly then\n        return data_note == filter_note\n    else\n        return string.find(data_note, filter_note, 1, true) ~= nil\n    end\nend\n\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-by-note\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter by Note\",\n        [\"de\"] = \"Filtern nach Notiz\",\n        [\"es\"] = \"Filtrar por Nota\",\n        [\"fr\"] = \"Filtrer par Note\"\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by their note field. Only data points matching the filter criteria will pass through.\n\nConfiguration:\n- **Filter Note**: The text to search for in notes\n- **Case Sensitive**: Match case exactly (default: false)\n- **Match Exactly**: Require exact match instead of substring (default: false)\n- **Invert**: Keep data points that DON'T match instead (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach ihrem Notiz-Feld. Nur Datenpunkte, die den Filterkriterien entsprechen, werden durchgelassen.\n\nKonfiguration:\n- **Filter-Notiz**: Der Text, nach dem in Notizen gesucht werden soll\n- **Groß-/Kleinschreibung beachten**: Groß-/Kleinschreibung exakt beachten (Standard: false)\n- **Exakt übereinstimmen**: Exakte Übereinstimmung statt Teilstring erforderlich (Standard: false)\n- **Invertieren**: Datenpunkte behalten, die NICHT übereinstimmen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por su campo de nota. Solo los puntos de datos que coincidan con los criterios del filtro pasarán.\n\nConfiguración:\n- **Filtrar Nota**: El texto a buscar en las notas\n- **Sensible a Mayúsculas**: Coincidir exactamente con mayúsculas y minúsculas (predeterminado: false)\n- **Coincidir Exactamente**: Requerir coincidencia exacta en lugar de subcadena (predeterminado: false)\n- **Invertir**: Mantener puntos de datos que NO coincidan (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par leur champ de note. Seuls les points de données correspondant aux critères du filtre passeront.\n\nConfiguration:\n- **Filtrer la Note**: Le texte à rechercher dans les notes\n- **Sensible à la Casse**: Correspondance exacte de la casse (par défaut: false)\n- **Correspondance Exacte**: Nécessite une correspondance exacte au lieu d'une sous-chaîne (par défaut: false)\n- **Inverser**: Conserver les points de données qui NE correspondent PAS (par défaut: false)\n]]\n    },\n    config = {\n        text {\n            id = \"filter_note\",\n            name = {\n                [\"en\"] = \"Filter Note\",\n                [\"de\"] = \"Filter-Notiz\",\n                [\"es\"] = \"Filtrar Nota\",\n                [\"fr\"] = \"Filtrer la Note\"\n            }\n        },\n        checkbox {\n            id = \"case_sensitive\",\n            name = {\n                [\"en\"] = \"Case Sensitive\",\n                [\"de\"] = \"Groß-/Kleinschreibung beachten\",\n                [\"es\"] = \"Sensible a Mayúsculas\",\n                [\"fr\"] = \"Sensible à la Casse\"\n            }\n        },\n        checkbox {\n            id = \"match_exactly\",\n            name = {\n                [\"en\"] = \"Match Exactly\",\n                [\"de\"] = \"Exakt übereinstimmen\",\n                [\"es\"] = \"Coincidir Exactamente\",\n                [\"fr\"] = \"Correspondance Exacte\"\n            }\n        },\n        checkbox {\n            id = \"invert\",\n            name = {\n                [\"en\"] = \"Invert\",\n                [\"de\"] = \"Invertieren\",\n                [\"es\"] = \"Invertir\",\n                [\"fr\"] = \"Inverser\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local filter_note = config and config.filter_note\n        local case_sensitive = config and config.case_sensitive or false\n        local match_exactly = config and config.match_exactly or false\n        local invert = config and config.invert or false\n\n        return function()\n            local data_point = source.dp()\n            local should_match = not invert\n            while data_point and (match(data_point, filter_note, case_sensitive, match_exactly) ~= should_match) do\n                data_point = source.dp()\n            end\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["filter-greater-than"]={
      script="-- Lua Function to filter data points by value (greater than threshold)\n-- Only passes through data points with values greater than a threshold\n\nlocal tng_config = require(\"tng.config\")\nlocal number = tng_config.number\nlocal checkbox = tng_config.checkbox\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-greater-than\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter Greater Than\",\n        [\"de\"] = \"Filtern größer als\",\n        [\"es\"] = \"Filtrar mayor que\",\n        [\"fr\"] = \"Filtrer supérieur à\",\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by value. Only data points with values greater than the threshold will pass through.\n\nConfiguration:\n- **Threshold**: The minimum value (exclusive by default)\n- **Include Equal**: Also include values equal to the threshold (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach Wert. Nur Datenpunkte mit Werten größer als der Schwellenwert werden durchgelassen.\n\nKonfiguration:\n- **Schwellenwert**: Der Mindestwert (standardmäßig exklusiv)\n- **Gleich einschließen**: Werte gleich dem Schwellenwert auch einschließen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por valor. Solo los puntos de datos con valores mayores que el umbral pasarán.\n\nConfiguración:\n- **Umbral**: El valor mínimo (exclusivo por defecto)\n- **Incluir igual**: También incluir valores iguales al umbral (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par valeur. Seuls les points de données avec des valeurs supérieures au seuil passeront.\n\nConfiguration:\n- **Seuil**: La valeur minimale (exclusive par défaut)\n- **Inclure égal**: Inclure également les valeurs égales au seuil (par défaut: false)\n]],\n    },\n    config = {\n        number {\n            id = \"threshold\",\n            name = {\n                [\"en\"] = \"Threshold\",\n                [\"de\"] = \"Schwellenwert\",\n                [\"es\"] = \"Umbral\",\n                [\"fr\"] = \"Seuil\",\n            },\n        },\n        checkbox {\n            id = \"include_equal\",\n            name = {\n                [\"en\"] = \"Include Equal\",\n                [\"de\"] = \"Gleich einschließen\",\n                [\"es\"] = \"Incluir igual\",\n                [\"fr\"] = \"Inclure égal\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local threshold = config and config.threshold or 0.0\n        local include_equal = config and config.include_equal or false\n\n        return function()\n            while true do\n                local data_point = source.dp()\n                if not data_point then\n                    return nil\n                end\n\n                local passes\n                if include_equal then\n                    passes = data_point.value >= threshold\n                else\n                    passes = data_point.value > threshold\n                end\n\n                if passes then\n                    return data_point\n                end\n            end\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["filter-less-than"]={
      script="-- Lua Function to filter data points by value (less than threshold)\n-- Only passes through data points with values less than a threshold\n\nlocal tng_config = require(\"tng.config\")\nlocal number = tng_config.number\nlocal checkbox = tng_config.checkbox\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-less-than\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter Less Than\",\n        [\"de\"] = \"Filtern kleiner als\",\n        [\"es\"] = \"Filtrar menor que\",\n        [\"fr\"] = \"Filtrer inférieur à\",\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by value. Only data points with values less than the threshold will pass through.\n\nConfiguration:\n- **Threshold**: The maximum value (exclusive by default)\n- **Include Equal**: Also include values equal to the threshold (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach Wert. Nur Datenpunkte mit Werten kleiner als der Schwellenwert werden durchgelassen.\n\nKonfiguration:\n- **Schwellenwert**: Der Maximalwert (standardmäßig exklusiv)\n- **Gleich einschließen**: Werte gleich dem Schwellenwert auch einschließen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por valor. Solo los puntos de datos con valores menores que el umbral pasarán.\n\nConfiguración:\n- **Umbral**: El valor máximo (exclusivo por defecto)\n- **Incluir igual**: También incluir valores iguales al umbral (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par valeur. Seuls les points de données avec des valeurs inférieures au seuil passeront.\n\nConfiguration:\n- **Seuil**: La valeur maximale (exclusive par défaut)\n- **Inclure égal**: Inclure également les valeurs égales au seuil (par défaut: false)\n]],\n    },\n    config = {\n        number {\n            id = \"threshold\",\n            name = {\n                [\"en\"] = \"Threshold\",\n                [\"de\"] = \"Schwellenwert\",\n                [\"es\"] = \"Umbral\",\n                [\"fr\"] = \"Seuil\",\n            },\n        },\n        checkbox {\n            id = \"include_equal\",\n            name = {\n                [\"en\"] = \"Include Equal\",\n                [\"de\"] = \"Gleich einschließen\",\n                [\"es\"] = \"Incluir igual\",\n                [\"fr\"] = \"Inclure égal\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local threshold = config and config.threshold or 0.0\n        local include_equal = config and config.include_equal or false\n\n        return function()\n            while true do\n                local data_point = source.dp()\n                if not data_point then\n                    return nil\n                end\n\n                local passes\n                if include_equal then\n                    passes = data_point.value <= threshold\n                else\n                    passes = data_point.value < threshold\n                end\n\n                if passes then\n                    return data_point\n                end\n            end\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    floor={
      script="-- Lua Function to floor values\n-- Rounds each data point's value down to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"floor\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Floor\",\n\9\9[\"de\"] = \"Abrunden\",\n\9\9[\"es\"] = \"Piso\",\n\9\9[\"fr\"] = \"Plancher\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nRounds each data point's value down to the nearest multiple of a specified number.\n\nConfiguration:\n- **Nearest**: Round down to the nearest multiple of this number (default: 1.0)\n]],\n\9\9[\"de\"] = [[\nRundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl ab.\n\nKonfiguration:\n- **Nächste**: Auf das nächste Vielfache dieser Zahl abrunden (Standard: 1.0)\n]],\n\9\9[\"es\"] = [[\nRedondea hacia abajo el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n- **Más cercano**: Redondear hacia abajo al múltiplo más cercano de este número (predeterminado: 1.0)\n]],\n\9\9[\"fr\"] = [[\nArrondit vers le bas la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n- **Plus proche**: Arrondir vers le bas au multiple le plus proche de ce nombre (par défaut: 1.0)\n]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Floor to nearest multiple\n\9\9\9data_point.value = math.floor(data_point.value / nearest) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    multiply={
      script="-- Lua Function to multiply data point values by a configurable number\n-- This function multiplies all incoming data point values by a specified multiplier\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"multiply\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Multiply Values\",\n        [\"de\"] = \"Werte multiplizieren\",\n        [\"es\"] = \"Multiplicar Valores\",\n        [\"fr\"] = \"Multiplier les Valeurs\"\n    },\n    description = {\n        [\"en\"] = [[\nMultiplies all incoming data point values by a specified multiplier.\n\nConfiguration:\n- **Multiplier**: The number to multiply all values by (default: 1.0)\n]],\n        [\"de\"] = [[\nMultipliziert alle eingehenden Datenpunktwerte mit einem bestimmten Multiplikator.\n\nKonfiguration:\n- **Multiplikator**: Die Zahl, mit der alle Werte multipliziert werden (Standard: 1.0)\n]],\n        [\"es\"] = [[\nMultiplica todos los valores de puntos de datos entrantes por un multiplicador especificado.\n\nConfiguración:\n- **Multiplicador**: El número por el cual multiplicar todos los valores (predeterminado: 1.0)\n]],\n        [\"fr\"] = [[\nMultiplie toutes les valeurs de points de données entrantes par un multiplicateur spécifié.\n\nConfiguration:\n- **Multiplicateur**: Le nombre par lequel multiplier toutes les valeurs (par défaut: 1.0)\n]]\n    },\n    config = {\n        number {\n            id = \"multiplier\",\n            name = {\n                [\"en\"] = \"Multiplier\",\n                [\"de\"] = \"Multiplikator\",\n                [\"es\"] = \"Multiplicador\",\n                [\"fr\"] = \"Multiplicateur\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local multiplier = config and config.multiplier or 1.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value * multiplier\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["offset-value"]={
      script="-- Lua Function to offset data point values by a configurable number\n-- This function adds a constant offset to all incoming data point values\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"offset-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Offset Value\",\n        [\"de\"] = \"Wert verschieben\",\n        [\"es\"] = \"Desplazar Valor\",\n        [\"fr\"] = \"Décaler la Valeur\"\n    },\n    description = {\n        [\"en\"] = [[\nAdds a constant offset to all incoming data point values.\n\nConfiguration:\n- **Offset**: The number to add to all values (default: 0.0). Use negative values to subtract.\n]],\n        [\"de\"] = [[\nFügt allen eingehenden Datenpunktwerten einen konstanten Offset hinzu.\n\nKonfiguration:\n- **Offset**: Die Zahl, die zu allen Werten addiert wird (Standard: 0.0). Verwenden Sie negative Werte zum Subtrahieren.\n]],\n        [\"es\"] = [[\nAñade un desplazamiento constante a todos los valores de puntos de datos entrantes.\n\nConfiguración:\n- **Desplazamiento**: El número a añadir a todos los valores (predeterminado: 0.0). Use valores negativos para restar.\n]],\n        [\"fr\"] = [[\nAjoute un décalage constant à toutes les valeurs de points de données entrantes.\n\nConfiguration:\n- **Décalage**: Le nombre à ajouter à toutes les valeurs (par défaut: 0.0). Utilisez des valeurs négatives pour soustraire.\n]]\n    },\n    config = {\n        number {\n            id = \"offset\",\n            default = 0.0,\n            name = {\n                [\"en\"] = \"Offset\",\n                [\"de\"] = \"Offset\",\n                [\"es\"] = \"Desplazamiento\",\n                [\"fr\"] = \"Décalage\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local offset = config and config.offset or 0.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value + offset\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["override-label"]={
      script="-- Lua Function to override the label of all data points with a configurable string\n-- This function sets all incoming data point labels to a specified value\n\nlocal text = require(\"tng.config\").text\n\nreturn {\n    -- Configuration metadata\n    id = \"override-label\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Label\",\n        [\"de\"] = \"Label überschreiben\",\n        [\"es\"] = \"Sobrescribir Etiqueta\",\n        [\"fr\"] = \"Remplacer l'Étiquette\",\n    },\n    description = {\n        [\"en\"] = [[\nSets all incoming data point labels to a specified value\n]],\n        [\"de\"] = [[\nSetzt alle eingehenden Datenpunkt-Labels auf einen bestimmten Wert\n]],\n        [\"es\"] = [[\nEstablece todas las etiquetas de puntos de datos entrantes en un valor especificado\n]],\n        [\"fr\"] = [[\nDéfinit toutes les étiquettes de points de données entrantes sur une valeur spécifiée\n]],\n    },\n    config = {\n        text {\n            id = \"new_label\",\n            name = {\n                [\"en\"] = \"New Label\",\n                [\"de\"] = \"Neues Label\",\n                [\"es\"] = \"Nueva Etiqueta\",\n                [\"fr\"] = \"Nouvelle Étiquette\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_label = config and config.new_label\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_label then\n                return data_point\n            end\n            data_point.label = new_label\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["override-note"]={
      script="-- Lua Function to override the note of all data points with a configurable string\n-- This function sets all incoming data point notes to a specified value\n\nlocal text = require(\"tng.config\").text\n\nreturn {\n    -- Configuration metadata\n    id = \"override-note\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Note\",\n        [\"de\"] = \"Notiz überschreiben\",\n        [\"es\"] = \"Sobrescribir Nota\",\n        [\"fr\"] = \"Remplacer la Note\",\n    },\n    description = {\n        [\"en\"] = [[\nSets all incoming data point notes to a specified value\n]],\n        [\"de\"] = [[\nSetzt alle eingehenden Datenpunkt-Notizen auf einen bestimmten Wert\n]],\n        [\"es\"] = [[\nEstablece todas las notas de puntos de datos entrantes en un valor especificado\n]],\n        [\"fr\"] = [[\nDéfinit toutes les notes de points de données entrantes sur une valeur spécifiée\n]],\n    },\n    config = {\n        text {\n            id = \"new_note\",\n            name = {\n                [\"en\"] = \"New Note\",\n                [\"de\"] = \"Neue Notiz\",\n                [\"es\"] = \"Nueva Nota\",\n                [\"fr\"] = \"Nouvelle Note\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_note = config and config.new_note\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_note then\n                return data_point\n            end\n            data_point.note = new_note\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["override-value"]={
      script="-- Lua Function to override the value of all data points with a configurable number\n-- This function sets all incoming data point values to a specified value\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"override-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Value\",\n        [\"de\"] = \"Wert überschreiben\",\n        [\"es\"] = \"Sobrescribir Valor\",\n        [\"fr\"] = \"Remplacer la Valeur\",\n    },\n    description = {\n        [\"en\"] = [[\nSets all incoming data point values to a specified value\n]],\n        [\"de\"] = [[\nSetzt alle eingehenden Datenpunktwerte auf einen bestimmten Wert\n]],\n        [\"es\"] = [[\nEstablece todos los valores de puntos de datos entrantes en un valor especificado\n]],\n        [\"fr\"] = [[\nDéfinit toutes les valeurs de points de données entrantes sur une valeur spécifiée\n]],\n    },\n    config = {\n        number {\n            id = \"new_value\",\n            name = {\n                [\"en\"] = \"New Value\",\n                [\"de\"] = \"Neuer Wert\",\n                [\"es\"] = \"Nuevo Valor\",\n                [\"fr\"] = \"Nouvelle Valeur\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_value = config and config.new_value\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_value then\n                return data_point\n            end\n            data_point.value = new_value\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["periodic-data-points"]={
      script="-- Lua Function to generate periodic data points at regular intervals\n-- This function creates data points with value=1 at deterministic timestamps\n\nlocal core = require(\"tng.core\")\nlocal enum = require(\"tng.config\").enum\nlocal uint = require(\"tng.config\").uint\nlocal localtime = require(\"tng.config\").localtime\nlocal instant = require(\"tng.config\").instant\n\nlocal now_time = core.time()\nlocal now = now_time and now_time.timestamp or 0\n\nreturn {\n    -- Configuration metadata\n    id = \"periodic-data-points\",\n    version = \"1.0.0\",\n    inputCount = 0, -- This is a generator, not a transformer\n    categories = { \"_generators\" },\n    title = {\n        [\"en\"] = \"Periodic Data Points\",\n        [\"de\"] = \"Periodische Datenpunkte\",\n        [\"es\"] = \"Puntos de Datos Periódicos\",\n        [\"fr\"] = \"Points de Données Périodiques\",\n    },\n    description = {\n        [\"en\"] = [[\nGenerates data points with value=1 at regular intervals going back in time.\n\nConfiguration:\n- **Period**: Time period unit (Day, Week, Month, Year)\n- **Period Multiplier**: Generate data point every N periods (e.g., every 2 days)\n- **Time of Day**: The time of day for each data point\n- **Cutoff**: Stop generating data points at this date/time\n\nGenerated data points will have:\n- value = 1.0\n- label = \"\" (empty)\n- note = \"\" (empty)\n- Deterministic timestamps at the specified time of day, spaced by the period\n\nThe function generates data points on-demand, working backwards from now to the cutoff.]],\n        [\"de\"] = [[\nGeneriert Datenpunkte mit Wert=1 in regelmäßigen Abständen zurück in der Zeit.\n\nKonfiguration:\n- **Periode**: Zeitperiodeneinheit (Tag, Woche, Monat, Jahr)\n- **Periodenmultiplikator**: Datenpunkt alle N Perioden generieren (z.B. alle 2 Tage)\n- **Tageszeit**: Die Tageszeit für jeden Datenpunkt\n- **Grenzwert**: Generierung bei diesem Datum/Zeit stoppen\n\nGenerierte Datenpunkte haben:\n- Wert = 1.0\n- Label = \"\" (leer)\n- Notiz = \"\" (leer)\n- Deterministische Zeitstempel zur angegebenen Tageszeit, im Abstand der Periode\n\nDie Funktion generiert Datenpunkte bei Bedarf, rückwärts von jetzt bis zum Grenzwert.]],\n        [\"es\"] = [[\nGenera puntos de datos con valor=1 a intervalos regulares retrocediendo en el tiempo.\n\nConfiguración:\n- **Período**: Unidad de período de tiempo (Día, Semana, Mes, Año)\n- **Multiplicador de Período**: Generar punto de datos cada N períodos (ej. cada 2 días)\n- **Hora del Día**: La hora del día para cada punto de datos\n- **Límite**: Detener generación de puntos de datos en esta fecha/hora\n\nLos puntos de datos generados tendrán:\n- valor = 1.0\n- etiqueta = \"\" (vacío)\n- nota = \"\" (vacío)\n- Marcas de tiempo determinísticas a la hora especificada, espaciadas por el período\n\nLa función genera puntos de datos bajo demanda, retrocediendo desde ahora hasta el límite.]],\n        [\"fr\"] = [[\nGénère des points de données avec valeur=1 à intervalles réguliers en remontant dans le temps.\n\nConfiguration:\n- **Période**: Unité de période de temps (Jour, Semaine, Mois, Année)\n- **Multiplicateur de Période**: Générer un point de données tous les N périodes (ex. tous les 2 jours)\n- **Heure de la Journée**: L'heure de la journée pour chaque point de données\n- **Limite**: Arrêter la génération de points de données à cette date/heure\n\nLes points de données générés auront:\n- valeur = 1.0\n- étiquette = \"\" (vide)\n- note = \"\" (vide)\n- Horodatages déterministes à l'heure spécifiée, espacés par la période\n\nLa fonction génère des points de données à la demande, en remontant de maintenant jusqu'à la limite.]],\n    },\n    config = {\n        enum {\n            id = \"period\",\n            name = \"_period\",\n            options = { \"_day\", \"_week\", \"_month\", \"_year\" },\n            default = \"_day\",\n        },\n        uint {\n            id = \"period_multiplier\",\n            name = \"_period_multiplier\",\n            default = 1,\n        },\n        localtime {\n            id = \"time_of_day\",\n            name = \"_time_of_day\",\n            default = 12 * core.DURATION.HOUR,\n        },\n        instant {\n            id = \"cutoff\",\n            name = \"_cutoff\",\n            default = now - (365 * core.DURATION.DAY),\n        },\n    },\n\n    -- Generator function\n    generator = function(_, config)\n        -- Parse configuration with defaults\n        local period_str = config and config.period or error(\"Period configuration is required\")\n        local period_multiplier = (config and config.period_multiplier) or 1\n        -- Don't allow 0 multiplier, fallback to 1\n        if period_multiplier == 0 then\n            period_multiplier = 1\n        end\n        local time_of_day_ms = config and config.time_of_day or error(\"Time of Day configuration is required\")\n        local cutoff_timestamp = config and config.cutoff or error(\"Cutoff configuration is required\")\n\n        -- Map enum string to core.PERIOD constant\n        local period_map = {\n            [\"_day\"] = core.PERIOD.DAY,\n            [\"_week\"] = core.PERIOD.WEEK,\n            [\"_month\"] = core.PERIOD.MONTH,\n            [\"_year\"] = core.PERIOD.YEAR,\n        }\n        local period = period_map[period_str]\n\n        -- Helper: apply time_of_day to a timestamp\n        local function apply_time_of_day(timestamp)\n            local hours = math.floor(time_of_day_ms / core.DURATION.HOUR)\n            local remaining = time_of_day_ms % core.DURATION.HOUR\n            local minutes = math.floor(remaining / core.DURATION.MINUTE)\n            remaining = remaining % core.DURATION.MINUTE\n            local seconds = math.floor(remaining / core.DURATION.SECOND)\n\n            local date = core.date(timestamp)\n            date.hour = hours\n            date.min = minutes\n            date.sec = seconds\n\n            return core.time(date)\n        end\n\n        -- Create anchor: cutoff with time_of_day applied (fixed, deterministic)\n        local anchor = apply_time_of_day(cutoff_timestamp)\n\n        -- If applying time_of_day moved us backwards, shift forward by days\n        -- (not the full period) to get past the cutoff without losing data\n        while anchor.timestamp < cutoff_timestamp do\n            anchor = core.shift(anchor, core.PERIOD.DAY, 1)\n        end\n\n        -- Get current time for comparison\n        local now = core.time().timestamp\n\n        -- If cutoff is in the future, no data points to generate\n        if anchor.timestamp > now then\n            return function()\n                return nil\n            end\n        end\n\n        -- Estimate number of periods elapsed since anchor\n        local elapsed_ms = now - anchor.timestamp\n        local estimated_periods\n\n        if period == core.PERIOD.DAY then\n            local period_duration_ms = period_multiplier * core.DURATION.DAY\n            estimated_periods = math.floor(elapsed_ms / period_duration_ms)\n        elseif period == core.PERIOD.WEEK then\n            local period_duration_ms = period_multiplier * core.DURATION.WEEK\n            estimated_periods = math.floor(elapsed_ms / period_duration_ms)\n        elseif period == core.PERIOD.MONTH then\n            -- Average month length: 30.44 days\n            local avg_month_ms = 30.44 * core.DURATION.DAY\n            local period_duration_ms = period_multiplier * avg_month_ms\n            estimated_periods = math.floor(elapsed_ms / period_duration_ms)\n        elseif period == core.PERIOD.YEAR then\n            -- Average year length: 365.25 days\n            local avg_year_ms = 365.25 * core.DURATION.DAY\n            local period_duration_ms = period_multiplier * avg_year_ms\n            estimated_periods = math.floor(elapsed_ms / period_duration_ms)\n        else\n            error(\"Invalid period: \" .. tostring(period_str))\n        end\n\n        -- Jump close to now with one large shift\n        local candidate = core.shift(anchor, period, estimated_periods * period_multiplier)\n\n        -- Fine-tune: shift forward until we pass \"now\"\n        while candidate.timestamp <= now do\n            candidate = core.shift(candidate, period, period_multiplier)\n        end\n\n        -- Back up one step to get the most recent data point <= now\n        local current = core.shift(candidate, period, -period_multiplier)\n\n        -- Return iterator function\n        return function()\n            -- Check if we've gone past the anchor (cutoff with time applied)\n            if current.timestamp < anchor.timestamp then\n                return nil\n            end\n\n            -- Create data point at current timestamp\n            local data_point = {\n                timestamp = current.timestamp,\n                offset = current.offset,\n                value = 1.0,\n                label = \"\",\n                note = \"\",\n            }\n\n            -- Shift backwards by period * period_multiplier for next iteration\n            current = core.shift(current, period, -period_multiplier)\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["random-value"]={
      script="-- Lua Function to override data point values with random values\n-- This function replaces all incoming data point values with random numbers between min and max\n\nlocal number = require(\"tng.config\").number\nlocal uint = require(\"tng.config\").uint\nlocal core = require(\"tng.core\")\n\nlocal now_time = core.time()\nlocal now = now_time and now_time.timestamp or 0\n\nreturn {\n    -- Configuration metadata\n    id = \"random-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_randomisers\"},\n    title = {\n        [\"en\"] = \"Random Value\",\n        [\"de\"] = \"Zufälliger Wert\",\n        [\"es\"] = \"Valor Aleatorio\",\n        [\"fr\"] = \"Valeur Aléatoire\",\n    },\n    description = {\n        [\"en\"] = [[\nReplaces all incoming data point values with random numbers between min and max.\n\nConfiguration:\n- **Min Value**: The minimum value for random generation\n- **Max Value**: The maximum value for random generation\n- **Seed**: Random seed for reproducible results (defaults to current UTC timestamp)\n\nThe function automatically swaps min and max if max is smaller than min.]],\n        [\"de\"] = [[\nErsetzt alle eingehenden Datenpunktwerte durch Zufallszahlen zwischen Min und Max.\n\nKonfiguration:\n- **Minimalwert**: Der Minimalwert für die Zufallsgenerierung\n- **Maximalwert**: Der Maximalwert für die Zufallsgenerierung\n- **Seed**: Zufalls-Seed für reproduzierbare Ergebnisse (Standard: aktueller UTC-Zeitstempel)\n\nDie Funktion tauscht automatisch Min und Max, wenn Max kleiner als Min ist.]],\n        [\"es\"] = [[\nReemplaza todos los valores de puntos de datos entrantes con números aleatorios entre mín y máx.\n\nConfiguración:\n- **Valor Mínimo**: El valor mínimo para la generación aleatoria\n- **Valor Máximo**: El valor máximo para la generación aleatoria\n- **Semilla**: Semilla aleatoria para resultados reproducibles (predeterminado: marca de tiempo UTC actual)\n\nLa función intercambia automáticamente mín y máx si máx es menor que mín.]],\n        [\"fr\"] = [[\nRemplace toutes les valeurs de points de données entrantes par des nombres aléatoires entre min et max.\n\nConfiguration:\n- **Valeur Minimale**: La valeur minimale pour la génération aléatoire\n- **Valeur Maximale**: La valeur maximale pour la génération aléatoire\n- **Graine**: Graine aléatoire pour des résultats reproductibles (par défaut: horodatage UTC actuel)\n\nLa fonction échange automatiquement min et max si max est inférieur à min.]],\n    },\n    config = {\n        number {\n            id = \"min_value\",\n            name = \"_min_value\",\n            default = 0.0,\n        },\n        number {\n            id = \"max_value\",\n            name = \"_max_value\",\n            default = 1.0,\n        },\n        uint {\n            id = \"seed\",\n            name = \"_seed\",\n            default = now,\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local min_val = config and config.min_value or 0.0\n        local max_val = config and config.max_value or 1.0\n        local seed = config and config.seed or core.time().timestamp\n\n        -- Ensure min is always the smaller value\n        if min_val > max_val then\n            min_val, max_val = max_val, min_val\n        end\n\n        local range = max_val - min_val\n\n        -- Initialize random seed\n        math.randomseed(seed)\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            -- Generate random value between min and max\n            local random_value = min_val + (math.random() * range)\n            data_point.value = random_value\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    round={
      script="-- Lua Function to round values\n-- Rounds each data point's value to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"round\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Round\",\n\9\9[\"de\"] = \"Runden\",\n\9\9[\"es\"] = \"Redondear\",\n\9\9[\"fr\"] = \"Arrondir\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nRounds each data point's value to the nearest multiple of a specified number.\n\nConfiguration:\n- **Nearest**: Round to the nearest multiple of this number (default: 1.0)\n]],\n\9\9[\"de\"] = [[\nRundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl.\n\nKonfiguration:\n- **Nächste**: Auf das nächste Vielfache dieser Zahl runden (Standard: 1.0)\n]],\n\9\9[\"es\"] = [[\nRedondea el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n- **Más cercano**: Redondear al múltiplo más cercano de este número (predeterminado: 1.0)\n]],\n\9\9[\"fr\"] = [[\nArrondit la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n- **Plus proche**: Arrondir au multiple le plus proche de ce nombre (par défaut: 1.0)\n]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Round to nearest multiple\n\9\9\9data_point.value = math.floor((data_point.value / nearest) + 0.5) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["swap-label-note"]={
      script="-- Lua Function to swap label and note fields\n-- Swaps the label and note of each data point\n\nreturn {\n\9-- Configuration metadata\n\9id = \"swap-label-note\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_transform\"},\n\9title = {\n\9\9[\"en\"] = \"Swap Label and Note\",\n\9\9[\"de\"] = \"Label und Notiz tauschen\",\n\9\9[\"es\"] = \"Intercambiar etiqueta y nota\",\n\9\9[\"fr\"] = \"Échanger étiquette et note\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSwaps the label and note fields of each data point.\n]],\n\9\9[\"de\"] = [[\nTauscht die Label- und Notizfelder jedes Datenpunkts aus.\n]],\n\9\9[\"es\"] = [[\nIntercambia los campos de etiqueta y nota de cada punto de datos.\n]],\n\9\9[\"fr\"] = [[\nÉchange les champs étiquette et note de chaque point de données.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Swap label and note\n\9\9\9local temp = data_point.label\n\9\9\9data_point.label = data_point.note\n\9\9\9data_point.note = temp\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["time-between"]={
      script="-- Lua Function to calculate time between data points\n-- Outputs the duration in seconds between each data point and the previous one\n\nlocal core = require(\"tng.core\")\nlocal checkbox = require(\"tng.config\").checkbox\n\nreturn {\n\9-- Configuration metadata\n\9id = \"time-between\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Time Between\",\n\9\9[\"de\"] = \"Zeit dazwischen\",\n\9\9[\"es\"] = \"Tiempo entre\",\n\9\9[\"fr\"] = \"Temps entre\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nCalculates the duration in seconds between each data point and the previous one. The output value is the time difference in seconds and can be treated as a duration.\n\nConfiguration:\n- **Include Time to First**: Include the time between now and the first data point (default: false)\n]],\n\9\9[\"de\"] = [[\nBerechnet die Dauer in Sekunden zwischen jedem Datenpunkt und dem vorherigen. Der Ausgabewert ist die Zeitdifferenz in Sekunden und kann als Dauer behandelt werden.\n\nKonfiguration:\n- **Zeit zum Ersten einschließen**: Die Zeit zwischen jetzt und dem ersten Datenpunkt einschließen (Standard: false)\n]],\n\9\9[\"es\"] = [[\nCalcula la duración en segundos entre cada punto de datos y el anterior. El valor de salida es la diferencia de tiempo en segundos y puede tratarse como una duración.\n\nConfiguración:\n- **Incluir tiempo al primero**: Incluir el tiempo entre ahora y el primer punto de datos (predeterminado: false)\n]],\n\9\9[\"fr\"] = [[\nCalcule la durée en secondes entre chaque point de données et le précédent. La valeur de sortie est la différence de temps en secondes et peut être traitée comme une durée.\n\nConfiguration:\n- **Inclure le temps jusqu'au premier**: Inclure le temps entre maintenant et le premier point de données (par défaut: false)\n]],\n\9},\n\9config = {\n\9\9checkbox {\n\9\9\9id = \"include_first\",\n\9\9\9default = false,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Include Time to First\",\n\9\9\9\9[\"de\"] = \"Zeit zum Ersten einschließen\",\n\9\9\9\9[\"es\"] = \"Incluir tiempo al primero\",\n\9\9\9\9[\"fr\"] = \"Inclure le temps jusqu'au premier\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local include_first = config and config.include_first or false\n\9\9local previous_point = nil\n\n\9\9return function()\n\9\9\9-- Initialize on first call\n\9\9\9if previous_point == nil then\n\9\9\9\9local first_point = source.dp()\n\9\9\9\9if not first_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\n\9\9\9\9previous_point = first_point\n\n\9\9\9\9if include_first then\n\9\9\9\9\9-- Return synthetic point with time from now to first\n\9\9\9\9\9local now = core.time().timestamp\n\9\9\9\9\9local duration_seconds = (now - first_point.timestamp) / 1000.0\n\n\9\9\9\9\9return {\n\9\9\9\9\9\9timestamp = first_point.timestamp,\n\9\9\9\9\9\9offset = first_point.offset,\n\9\9\9\9\9\9value = duration_seconds,\n\9\9\9\9\9\9label = \"\",\n\9\9\9\9\9\9note = \"\",\n\9\9\9\9\9}\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9-- Get next data point\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Calculate duration from previous to current\n\9\9\9local duration_seconds = (previous_point.timestamp - data_point.timestamp) / 1000.0\n\n\9\9\9-- Create output point using previous point's identity\n\9\9\9local output_point = {\n\9\9\9\9timestamp = previous_point.timestamp,\n\9\9\9\9offset = previous_point.offset,\n\9\9\9\9value = duration_seconds,\n\9\9\9\9label = previous_point.label,\n\9\9\9\9note = previous_point.note,\n\9\9\9}\n\n\9\9\9-- Update state for next iteration\n\9\9\9previous_point = data_point\n\n\9\9\9return output_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-difference"]={
      script="-- Lua Function to calculate value differences\n-- Outputs the difference between each data point's value and the next one\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-difference\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\", \"_transform\"},\n\9title = {\n\9\9[\"en\"] = \"Value Difference\",\n\9\9[\"de\"] = \"Wertdifferenz\",\n\9\9[\"es\"] = \"Diferencia de valor\",\n\9\9[\"fr\"] = \"Différence de valeur\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nCalculates the difference between each data point's value and the next one. Each output point has its original identity with the value set to the difference.\n]],\n\9\9[\"de\"] = [[\nBerechnet die Differenz zwischen dem Wert jedes Datenpunkts und dem nächsten. Jeder Ausgabepunkt hat seine ursprüngliche Identität mit dem Wert auf die Differenz gesetzt.\n]],\n\9\9[\"es\"] = [[\nCalcula la diferencia entre el valor de cada punto de datos y el siguiente. Cada punto de salida tiene su identidad original con el valor establecido en la diferencia.\n]],\n\9\9[\"fr\"] = [[\nCalcule la différence entre la valeur de chaque point de données et la suivante. Chaque point de sortie a son identité d'origine avec la valeur définie sur la différence.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9local next_point = nil\n\n\9\9return function()\n\9\9\9-- Pre-load the next point on first call\n\9\9\9if next_point == nil then\n\9\9\9\9next_point = source.dp()\n\9\9\9\9if not next_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9-- Current point is what we'll output\n\9\9\9local current_point = next_point\n\n\9\9\9-- Pre-load the next point for the next iteration\n\9\9\9next_point = source.dp()\n\9\9\9if not next_point then\n\9\9\9\9-- No more points, can't calculate difference\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Calculate difference (current - next)\n\9\9\9local difference = current_point.value - next_point.value\n\n\9\9\9-- Return current point with difference as value\n\9\9\9return {\n\9\9\9\9timestamp = current_point.timestamp,\n\9\9\9\9offset = current_point.offset,\n\9\9\9\9value = difference,\n\9\9\9\9label = current_point.label,\n\9\9\9\9note = current_point.note,\n\9\9\9}\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-day-of-month"]={
      script="-- Lua Function to set value to day of month\n-- Sets each data point's value to its day of the month (1-31)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-day-of-month\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Day of Month\",\n\9\9[\"de\"] = \"Wert zu Tag des Monats\",\n\9\9[\"es\"] = \"Valor a día del mes\",\n\9\9[\"fr\"] = \"Valeur au jour du mois\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its day of the month (1-31).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seinen Tag des Monats (1-31).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su día del mes (1-31).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son jour du mois (1-31).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.day\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-day-of-week"]={
      script="-- Lua Function to set value to day of week\n-- Sets each data point's value to its day of the week (1-7, Monday is 1)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-day-of-week\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Day of Week\",\n\9\9[\"de\"] = \"Wert zu Wochentag\",\n\9\9[\"es\"] = \"Valor a día de la semana\",\n\9\9[\"fr\"] = \"Valeur au jour de la semaine\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its day of the week (1-7, where Monday is 1 and Sunday is 7).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seinen Wochentag (1-7, wobei Montag 1 und Sonntag 7 ist).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su día de la semana (1-7, donde lunes es 1 y domingo es 7).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son jour de la semaine (1-7, où lundi est 1 et dimanche est 7).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Get the date from the timestamp\n\9\9\9local date = core.date(data_point)\n\n\9\9\9-- Set value to day of week\n\9\9\9data_point.value = date.wday\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-hour-of-day"]={
      script="-- Lua Function to set value to hour of day\n-- Sets each data point's value to its hour of the day (0-23)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-hour-of-day\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Hour (0-23)\",\n\9\9[\"de\"] = \"Wert zu Stunde (0-23)\",\n\9\9[\"es\"] = \"Valor a hora (0-23)\",\n\9\9[\"fr\"] = \"Valeur à l'heure (0-23)\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its hour of the day (0-23).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seine Stunde des Tages (0-23).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su hora del día (0-23).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son heure du jour (0-23).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.hour or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-minute-of-hour"]={
      script="-- Lua Function to set value to minute of hour\n-- Sets each data point's value to its minute of the hour (0-59)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-minute-of-hour\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Minute of Hour\",\n\9\9[\"de\"] = \"Wert zu Minute der Stunde\",\n\9\9[\"es\"] = \"Valor a minuto de la hora\",\n\9\9[\"fr\"] = \"Valeur à la minute de l'heure\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its minute of the hour (0-59).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seine Minute der Stunde (0-59).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su minuto de la hora (0-59).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur sa minute de l'heure (0-59).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.min or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-month-of-year"]={
      script="-- Lua Function to set value to month of year\n-- Sets each data point's value to its month of the year (1-12)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-month-of-year\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Month of Year\",\n\9\9[\"de\"] = \"Wert zu Monat des Jahres\",\n\9\9[\"es\"] = \"Valor a mes del año\",\n\9\9[\"fr\"] = \"Valeur au mois de l'année\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its month of the year (1-12, where January is 1).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seinen Monat des Jahres (1-12, wobei Januar 1 ist).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su mes del año (1-12, donde enero es 1).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son mois de l'année (1-12, où janvier est 1).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.month\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-second-of-minute"]={
      script="-- Lua Function to set value to second of minute\n-- Sets each data point's value to its second of the minute (0-59)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-second-of-minute\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Second of Minute\",\n\9\9[\"de\"] = \"Wert zu Sekunde der Minute\",\n\9\9[\"es\"] = \"Valor a segundo del minuto\",\n\9\9[\"fr\"] = \"Valeur à la seconde de la minute\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its second of the minute (0-59).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seine Sekunde der Minute (0-59).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su segundo del minuto (0-59).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur sa seconde de la minute (0-59).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.sec or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-time-of-day"]={
      script="-- Lua Function to set value to time of day\n-- Sets each data point's value to the time of day in seconds since midnight\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-time-of-day\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Time of Day\",\n\9\9[\"de\"] = \"Wert zu Tageszeit\",\n\9\9[\"es\"] = \"Valor a hora del día\",\n\9\9[\"fr\"] = \"Valeur à l'heure de la journée\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to the time of day in seconds since midnight. The output is a duration value representing elapsed time since the start of the day.\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf die Tageszeit in Sekunden seit Mitternacht. Die Ausgabe ist ein Dauerwert, der die verstrichene Zeit seit Tagesbeginn darstellt.\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en la hora del día en segundos desde la medianoche. La salida es un valor de duración que representa el tiempo transcurrido desde el comienzo del día.\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur l'heure de la journée en secondes depuis minuit. La sortie est une valeur de durée représentant le temps écoulé depuis le début de la journée.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Get the date from the data point\n\9\9\9local date = core.date(data_point)\n\n\9\9\9-- Calculate seconds since midnight\n\9\9\9local seconds_since_midnight = (date.hour or 0) * 3600 + (date.min or 0) * 60 + (date.sec or 0)\n\n\9\9\9-- Set value to time of day in seconds\n\9\9\9data_point.value = seconds_since_midnight\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-year"]={
      script="-- Lua Function to set value to year\n-- Sets each data point's value to its year\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-year\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Year\",\n\9\9[\"de\"] = \"Wert zu Jahr\",\n\9\9[\"es\"] = \"Valor a año\",\n\9\9[\"fr\"] = \"Valeur à l'année\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its year (e.g., 2025).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf sein Jahr (z.B. 2025).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su año (p. ej., 2025).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son année (par exemple, 2025).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.year\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    }
  },
  published_at="2025-10-26T23:42:15Z",
  translations={
    _all_fields={
      de="Alle Felder",
      en="All Fields",
      es="Todos los campos",
      fr="Tous les champs"
    },
    _arithmetic={
      de="Arithmetik",
      en="Arithmetic",
      es="Aritmética",
      fr="Arithmétique"
    },
    _compare_by={
      de="Vergleichen nach",
      en="Compare By",
      es="Comparar por",
      fr="Comparer par"
    },
    _cutoff={
      de="Grenzwert",
      en="Cutoff",
      es="Límite",
      fr="Limite"
    },
    _day={
      de="Tag",
      en="Day",
      es="Día",
      fr="Jour"
    },
    _days={
      de="Tage",
      en="Days",
      es="Días",
      fr="Jours"
    },
    _filter={
      de="Filter",
      en="Filter",
      es="Filtro",
      fr="Filtre"
    },
    _frequency={
      de="Häufigkeit",
      en="Frequency",
      es="Frecuencia",
      fr="Fréquence"
    },
    _generators={
      de="Generatoren",
      en="Generators",
      es="Generadores",
      fr="Générateurs"
    },
    _hours={
      de="Stunden",
      en="Hours",
      es="Horas",
      fr="Heures"
    },
    _label_and_note={
      de="Label und Notiz",
      en="Label and Note",
      es="Etiqueta y nota",
      fr="Étiquette et note"
    },
    _label_only={
      de="Nur Label",
      en="Label Only",
      es="Solo etiqueta",
      fr="Étiquette uniquement"
    },
    _max_value={
      de="Maximalwert",
      en="Max Value",
      es="Valor Máximo",
      fr="Valeur Maximale"
    },
    _min_value={
      de="Minimalwert",
      en="Min Value",
      es="Valor Mínimo",
      fr="Valeur Minimale"
    },
    _minutes={
      de="Minuten",
      en="Minutes",
      es="Minutos",
      fr="Minutes"
    },
    _month={
      de="Monat",
      en="Month",
      es="Mes",
      fr="Mois"
    },
    _months={
      de="Monate",
      en="Months",
      es="Meses",
      fr="Mois"
    },
    _note_only={
      de="Nur Notiz",
      en="Note Only",
      es="Solo nota",
      fr="Note uniquement"
    },
    _period={
      de="Periode",
      en="Period",
      es="Período",
      fr="Période"
    },
    _period_multiplier={
      de="Periodenmultiplikator",
      en="Period Multiplier",
      es="Multiplicador de Período",
      fr="Multiplicateur de Période"
    },
    _randomisers={
      de="Zufallsgeneratoren",
      en="Randomisers",
      es="Aleatorizadores",
      fr="Générateurs Aléatoires"
    },
    _seconds={
      de="Sekunden",
      en="Seconds",
      es="Segundos",
      fr="Secondes"
    },
    _seed={
      de="Seed",
      en="Seed",
      es="Semilla",
      fr="Graine"
    },
    _time={
      de="Zeit",
      en="Time",
      es="Tiempo",
      fr="Temps"
    },
    _time_jitter={
      de="Zeitliche Streuung",
      en="Time Jitter",
      es="Variación de Tiempo",
      fr="Fluctuation Temporelle"
    },
    _time_of_day={
      de="Tageszeit",
      en="Time of Day",
      es="Hora del Día",
      fr="Heure de la Journée"
    },
    _transform={
      de="Transformieren",
      en="Transform",
      es="Transformar",
      fr="Transformer"
    },
    _value_and_label={
      de="Wert und Label",
      en="Value and Label",
      es="Valor y etiqueta",
      fr="Valeur et étiquette"
    },
    _value_and_note={
      de="Wert und Notiz",
      en="Value and Note",
      es="Valor y nota",
      fr="Valeur et note"
    },
    _value_only={
      de="Nur Wert",
      en="Value Only",
      es="Solo valor",
      fr="Valeur uniquement"
    },
    _week={
      de="Woche",
      en="Week",
      es="Semana",
      fr="Semaine"
    },
    _weeks={
      de="Wochen",
      en="Weeks",
      es="Semanas",
      fr="Semaines"
    },
    _year={
      de="Jahr",
      en="Year",
      es="Año",
      fr="Année"
    },
    _years={
      de="Jahre",
      en="Years",
      es="Años",
      fr="Années"
    }
  }
}
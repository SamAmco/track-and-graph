return {
  functions={
    ["a1-test"]={
      script="-- Example function demonstrating all available configuration types\n-- This function showcases text, number, checkbox, enum, uint, duration, localtime, and instant inputs\n\nlocal tng_config = require(\"tng.config\")\nlocal core = require(\"tng.core\")\nlocal text = tng_config.text\nlocal number = tng_config.number\nlocal checkbox = tng_config.checkbox\nlocal enum = tng_config.enum\nlocal uint = tng_config.uint\nlocal duration = tng_config.duration\nlocal localtime = tng_config.localtime\nlocal instant = tng_config.instant\n\nlocal now = core.time()\nlocal default_instant = now and now.timestamp -- Current time as epoch milliseconds\n\nreturn {\n\9id = \"a1-test\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = { \"_transform\" },\n\9title = {\n\9\9[\"en\"] = \"Configuration Types Demo\",\n\9\9[\"de\"] = \"Konfigurationstypen-Demo\",\n\9\9[\"es\"] = \"Demostración de tipos de configuración\",\n\9\9[\"fr\"] = \"Démonstration des types de configuration\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nDemonstrates all available configuration input types: text, number, checkbox, enum, uint, duration, localtime, and instant. This function passes through all data points unchanged.\n]],\n\9\9[\"de\"] = [[\nDemonstriert alle verfügbaren Konfigurationseingabetypen: Text, Nummer, Kontrollkästchen, Aufzählung, uint, Dauer, Ortszeit und Zeitpunkt. Diese Funktion gibt alle Datenpunkte unverändert weiter.\n]],\n\9\9[\"es\"] = [[\nDemuestra todos los tipos de entrada de configuración disponibles: texto, número, casilla de verificación, enumeración, uint, duración, hora local e instante. Esta función pasa todos los puntos de datos sin cambios.\n]],\n\9\9[\"fr\"] = [[\nDémontre tous les types d'entrée de configuration disponibles : texte, nombre, case à cocher, énumération, uint, durée, heure locale et instant. Cette fonction transmet tous les points de données inchangés.\n]],\n\9},\n\9config = {\n\9\9text {\n\9\9\9id = \"text_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Text Input\",\n\9\9\9\9[\"de\"] = \"Texteingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de texto\",\n\9\9\9\9[\"fr\"] = \"Saisie de texte\",\n\9\9\9},\n\9\9\9default = \"Example text\",\n\9\9},\n\9\9number {\n\9\9\9id = \"number_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Number Input\",\n\9\9\9\9[\"de\"] = \"Zahleneingabe\",\n\9\9\9\9[\"es\"] = \"Entrada numérica\",\n\9\9\9\9[\"fr\"] = \"Saisie numérique\",\n\9\9\9},\n\9\9\9default = 3.14,\n\9\9},\n\9\9checkbox {\n\9\9\9id = \"checkbox_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Checkbox Input\",\n\9\9\9\9[\"de\"] = \"Kontrollkästchen\",\n\9\9\9\9[\"es\"] = \"Casilla de verificación\",\n\9\9\9\9[\"fr\"] = \"Case à cocher\",\n\9\9\9},\n\9\9\9default = true,\n\9\9},\n\9\9enum {\n\9\9\9id = \"enum_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Enum Input\",\n\9\9\9\9[\"de\"] = \"Aufzählungseingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de enumeración\",\n\9\9\9\9[\"fr\"] = \"Saisie d'énumération\",\n\9\9\9},\n\9\9\9options = { \"_hours\", \"_days\", \"_weeks\" },\n\9\9\9default = \"_days\",\n\9\9},\n\9\9uint {\n\9\9\9id = \"uint_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Unsigned Integer Input\",\n\9\9\9\9[\"de\"] = \"Vorzeichenlose Ganzzahleingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de entero sin signo\",\n\9\9\9\9[\"fr\"] = \"Saisie d'entier non signé\",\n\9\9\9},\n\9\9\9default = 42,\n\9\9},\n\9\9duration {\n\9\9\9id = \"duration_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Duration Input\",\n\9\9\9\9[\"de\"] = \"Dauereingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de duración\",\n\9\9\9\9[\"fr\"] = \"Saisie de durée\",\n\9\9\9},\n\9\9\9default = 3600000, -- 1 hour (DURATION.HOUR)\n\9\9},\n\9\9localtime {\n\9\9\9id = \"localtime_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Time of Day Input\",\n\9\9\9\9[\"de\"] = \"Tageszeiteingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de hora del día\",\n\9\9\9\9[\"fr\"] = \"Saisie de l'heure de la journée\",\n\9\9\9},\n\9\9\9default = 52200000, -- 14:30 (2:30 PM) = 14.5 hours * DURATION.HOUR\n\9\9},\n\9\9instant {\n\9\9\9id = \"instant_example\",\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Date & Time Input\",\n\9\9\9\9[\"de\"] = \"Datum & Uhrzeit-Eingabe\",\n\9\9\9\9[\"es\"] = \"Entrada de fecha y hora\",\n\9\9\9\9[\"fr\"] = \"Saisie de date et heure\",\n\9\9\9},\n\9\9\9default = default_instant, -- Current time as epoch milliseconds\n\9\9},\n\9},\n\n\9generator = function(source, config)\n\9\9-- Access configuration values (not used in this demo)\n\9\9local text_val = config and config.text_example\n\9\9local number_val = config and config.number_example\n\9\9local checkbox_val = config and config.checkbox_example\n\9\9local enum_val = config and config.enum_example\n\9\9local uint_val = config and config.uint_example\n\9\9local duration_val = config and config.duration_example\n\9\9local localtime_val = config and config.localtime_example\n\9\9local instant_val = config and config.instant_example\n\n\9\9-- Pass through all data points unchanged\n\9\9return function()\n\9\9\9local dp = source.dp()\n\9\9\9if not dp then\n\9\9\9\9return nil\n\9\9\9end\n\9\9\9dp.timestamp = instant_val or dp.timestamp\n\9\9\9return dp\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["absolute-value"]={
      script="-- Lua Function to take absolute value\n-- Converts all data point values to their absolute value\n\nreturn {\n\9-- Configuration metadata\n\9id = \"absolute-value\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Absolute Value\",\n\9\9[\"de\"] = \"Absolutwert\",\n\9\9[\"es\"] = \"Valor absoluto\",\n\9\9[\"fr\"] = \"Valeur absolue\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nConverts each data point's value to its absolute value (removes negative sign).\n]],\n\9\9[\"de\"] = [[\nKonvertiert den Wert jedes Datenpunkts zu seinem Absolutwert (entfernt negatives Vorzeichen).\n]],\n\9\9[\"es\"] = [[\nConvierte el valor de cada punto de datos a su valor absoluto (elimina el signo negativo).\n]],\n\9\9[\"fr\"] = [[\nConvertit la valeur de chaque point de données en sa valeur absolue (supprime le signe négatif).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Convert to absolute value\n\9\9\9data_point.value = math.abs(data_point.value)\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ceil={
      script="-- Lua Function to ceiling values\n-- Rounds each data point's value up to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"ceil\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Ceiling\",\n\9\9[\"de\"] = \"Aufrunden\",\n\9\9[\"es\"] = \"Techo\",\n\9\9[\"fr\"] = \"Plafond\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nRounds each data point's value up to the nearest multiple of a specified number.\n\nConfiguration:\n- **Nearest**: Round up to the nearest multiple of this number (default: 1.0)\n]],\n\9\9[\"de\"] = [[\nRundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl auf.\n\nKonfiguration:\n- **Nächste**: Auf das nächste Vielfache dieser Zahl aufrunden (Standard: 1.0)\n]],\n\9\9[\"es\"] = [[\nRedondea hacia arriba el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n- **Más cercano**: Redondear hacia arriba al múltiplo más cercano de este número (predeterminado: 1.0)\n]],\n\9\9[\"fr\"] = [[\nArrondit vers le haut la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n- **Plus proche**: Arrondir vers le haut au multiple le plus proche de ce nombre (par défaut: 1.0)\n]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Ceiling to nearest multiple\n\9\9\9data_point.value = math.ceil(data_point.value / nearest) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["cumulative-value"]={
      script="-- Lua Function to calculate cumulative sum of data point values\n-- This function computes a running total, optionally resetting on specific labels\n\nlocal checkbox = require(\"tng.config\").checkbox\nlocal text = require(\"tng.config\").text\n\nreturn {\n    -- Configuration metadata\n    id = \"cumulative-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Cumulative Value\",\n        [\"de\"] = \"Kumulativer Wert\",\n        [\"es\"] = \"Valor Acumulativo\",\n        [\"fr\"] = \"Valeur Cumulative\",\n    },\n    description = {\n        [\"en\"] = \"Calculates the cumulative sum of data point values. Optionally resets accumulation when a specific label is encountered.\",\n        [\"de\"] = \"Berechnet die kumulative Summe der Datenpunktwerte. Setzt optional die Akkumulation zurück, wenn ein bestimmtes Label gefunden wird.\",\n        [\"es\"] = \"Calcula la suma acumulativa de los valores de puntos de datos. Opcionalmente reinicia la acumulación cuando se encuentra una etiqueta específica.\",\n        [\"fr\"] = \"Calcule la somme cumulative des valeurs de points de données. Réinitialise optionnellement l'accumulation lorsqu'une étiquette spécifique est rencontrée.\",\n    },\n    config = {\n        checkbox {\n            id = \"enable_reset\",\n            name = \"_reset_on_label_match\",\n            default = false,\n        },\n        text {\n            id = \"reset_label\",\n            name = \"_reset_label\",\n            default = \"\",\n        },\n        checkbox {\n            id = \"exact_match\",\n            name = \"_match_exactly\",\n            default = false,\n        },\n        checkbox {\n            id = \"case_sensitive\",\n            name = \"_case_sensitive\",\n            default = true,\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local enable_reset = config.enable_reset\n        local reset_label = config.reset_label\n        local exact_match = config.exact_match\n        local case_sensitive = config.case_sensitive\n\n        -- Helper function to check if a label matches\n        local function label_matches(dp_label)\n            if not enable_reset then\n                return false\n            end\n\n            local label_to_check = dp_label or \"\"\n            local pattern = reset_label\n\n            -- Apply case insensitivity if needed\n            if not case_sensitive then\n                label_to_check = label_to_check:lower()\n                pattern = pattern:lower()\n            end\n\n            -- Check match type\n            if exact_match then\n                return label_to_check == pattern\n            else\n                -- search for pattern from the start, pattern matching disabled\n                return label_to_check:find(pattern, 1, true) ~= nil\n            end\n        end\n\n        -- Drain all data points from source (returns in reverse chronological order)\n        local all_points = source.dpall()\n\n        -- Calculate cumulative values by iterating in reverse (chronologically)\n        -- Mutate data points in place\n        local cumulative_sum = 0\n        for i = #all_points, 1, -1 do\n            local data_point = all_points[i]\n\n            -- Check if we should reset\n            if label_matches(data_point.label) then\n                cumulative_sum = 0\n            end\n\n            -- Add current value to cumulative sum\n            cumulative_sum = cumulative_sum + data_point.value\n\n            -- Update the data point's value in place\n            data_point.value = cumulative_sum\n        end\n\n        -- all_points is still in reverse chronological order, return iterator\n        local index = 0\n        return function()\n            index = index + 1\n            return all_points[index]\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["distinct-until-changed"]={
      script="-- Lua Function to filter out consecutive duplicates based on selected fields\n-- Only passes through data points when the selected fields change from the previous one\n\nlocal enum = require(\"tng.config\").enum\n\nreturn {\n\9-- Configuration metadata\n\9id = \"distinct-until-changed\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = { \"_filter\" },\n\9title = {\n\9\9[\"en\"] = \"Distinct Until Changed\",\n\9\9[\"de\"] = \"Eindeutig bis geändert\",\n\9\9[\"es\"] = \"Distinto hasta cambio\",\n\9\9[\"fr\"] = \"Distinct jusqu'au changement\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nFilters out consecutive duplicates based on the selected fields. Only data points where the selected fields differ from the previous one will pass through.\n\n- **All Fields** - Compare value, label, and note\n- **Value Only** - Compare value only\n- **Label Only** - Compare label only\n- **Note Only** - Compare note only\n- **Value and Label** - Compare value and label\n- **Value and Note** - Compare value and note\n- **Label and Note** - Compare label and note\n]],\n\9\9[\"de\"] = [[\nFiltert aufeinanderfolgende Duplikate basierend auf den ausgewählten Feldern heraus. Nur Datenpunkte, bei denen sich die ausgewählten Felder vom vorherigen unterscheiden, werden durchgelassen.\n\n- **Alle Felder** - Vergleicht Wert, Label und Notiz\n- **Nur Wert** - Vergleicht nur Wert\n- **Nur Label** - Vergleicht nur Label\n- **Nur Notiz** - Vergleicht nur Notiz\n- **Wert und Label** - Vergleicht Wert und Label\n- **Wert und Notiz** - Vergleicht Wert und Notiz\n- **Label und Notiz** - Vergleicht Label und Notiz\n]],\n\9\9[\"es\"] = [[\nFiltra duplicados consecutivos basándose en los campos seleccionados. Solo los puntos de datos donde los campos seleccionados difieren del anterior pasarán.\n\n- **Todos los campos** - Compara valor, etiqueta y nota\n- **Solo valor** - Compara solo valor\n- **Solo etiqueta** - Compara solo etiqueta\n- **Solo nota** - Compara solo nota\n- **Valor y etiqueta** - Compara valor y etiqueta\n- **Valor y nota** - Compara valor y nota\n- **Etiqueta y nota** - Compara etiqueta y nota\n]],\n\9\9[\"fr\"] = [[\nFiltre les doublons consécutifs en fonction des champs sélectionnés. Seuls les points de données où les champs sélectionnés diffèrent du précédent passeront.\n\n- **Tous les champs** - Compare valeur, étiquette et note\n- **Valeur uniquement** - Compare la valeur uniquement\n- **Étiquette uniquement** - Compare l'étiquette uniquement\n- **Note uniquement** - Compare la note uniquement\n- **Valeur et étiquette** - Compare valeur et étiquette\n- **Valeur et note** - Compare valeur et note\n- **Étiquette et note** - Compare étiquette et note\n]],\n\9},\n\9config = {\n\9\9enum {\n\9\9\9id = \"compare_by\",\n\9\9\9name = \"_compare_by\",\n\9\9\9options = {\n\9\9\9\9\"_all_fields\",\n\9\9\9\9\"_value_only\",\n\9\9\9\9\"_label_only\",\n\9\9\9\9\"_note_only\",\n\9\9\9\9\"_value_and_label\",\n\9\9\9\9\"_value_and_note\",\n\9\9\9\9\"_label_and_note\",\n\9\9\9},\n\9\9\9default = \"_all_fields\",\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local compare_by = config and config.compare_by or \"_all_fields\"\n\n\9\9local last_value = nil\n\9\9local last_label = nil\n\9\9local last_note = nil\n\n\9\9return function()\n\9\9\9while true do\n\9\9\9\9local data_point = source.dp()\n\9\9\9\9if not data_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\n\9\9\9\9local current_value = data_point.value\n\9\9\9\9local current_label = data_point.label\n\9\9\9\9local current_note = data_point.note\n\n\9\9\9\9local is_different = false\n\n\9\9\9\9if compare_by == \"_all_fields\" then\n\9\9\9\9\9is_different = (current_value ~= last_value)\n\9\9\9\9\9\9or (current_label ~= last_label)\n\9\9\9\9\9\9or (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_value_only\" then\n\9\9\9\9\9is_different = (current_value ~= last_value)\n\9\9\9\9elseif compare_by == \"_label_only\" then\n\9\9\9\9\9is_different = (current_label ~= last_label)\n\9\9\9\9elseif compare_by == \"_note_only\" then\n\9\9\9\9\9is_different = (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_value_and_label\" then\n\9\9\9\9\9is_different = (current_value ~= last_value) or (current_label ~= last_label)\n\9\9\9\9elseif compare_by == \"_value_and_note\" then\n\9\9\9\9\9is_different = (current_value ~= last_value) or (current_note ~= last_note)\n\9\9\9\9elseif compare_by == \"_label_and_note\" then\n\9\9\9\9\9is_different = (current_label ~= last_label) or (current_note ~= last_note)\n\9\9\9\9end\n\n\9\9\9\9if is_different then\n\9\9\9\9\9last_value = current_value\n\9\9\9\9\9last_label = current_label\n\9\9\9\9\9last_note = current_note\n\9\9\9\9\9return data_point\n\9\9\9\9end\n\9\9\9end\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    divide={
      script="-- Lua Function to divide data point values by a configurable number\n-- This function divides all incoming data point values by a specified divisor\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"divide\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Divide Values\",\n        [\"de\"] = \"Werte dividieren\",\n        [\"es\"] = \"Dividir Valores\",\n        [\"fr\"] = \"Diviser les Valeurs\"\n    },\n    description = {\n        [\"en\"] = [[\nDivides all incoming data point values by a specified divisor.\n\nConfiguration:\n- **Divisor**: The number to divide all values by (default: 1.0)\n]],\n        [\"de\"] = [[\nDividiert alle eingehenden Datenpunktwerte durch einen bestimmten Divisor.\n\nKonfiguration:\n- **Divisor**: Die Zahl, durch die alle Werte dividiert werden (Standard: 1.0)\n]],\n        [\"es\"] = [[\nDivide todos los valores de puntos de datos entrantes por un divisor especificado.\n\nConfiguración:\n- **Divisor**: El número por el cual dividir todos los valores (predeterminado: 1.0)\n]],\n        [\"fr\"] = [[\nDivise toutes les valeurs de points de données entrantes par un diviseur spécifié.\n\nConfiguration:\n- **Diviseur**: Le nombre par lequel diviser toutes les valeurs (par défaut: 1.0)\n]]\n    },\n    config = {\n        number {\n            id = \"divisor\",\n            default = 1.0,\n            name = {\n                [\"en\"] = \"Divisor\",\n                [\"de\"] = \"Divisor\",\n                [\"es\"] = \"Divisor\",\n                [\"fr\"] = \"Diviseur\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local divisor = config and config.divisor or 1.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value / divisor\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["filter-after-cutoff"]={
      script="-- Lua Function to filter data points after a cutoff timestamp\n-- This function only passes through data points that occur at or after the specified cutoff time\n\nlocal instant = require(\"tng.config\").instant\nlocal core = require(\"tng.core\")\n\nlocal now_time = core.time()\nlocal now = now_time and now_time.timestamp or 0\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-after-cutoff\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\", \"_time\"},\n    title = {\n        [\"en\"] = \"Filter After Cutoff\",\n        [\"de\"] = \"Filtern nach Grenzwert\",\n        [\"es\"] = \"Filtrar Después del Límite\",\n        [\"fr\"] = \"Filtrer Après la Limite\",\n    },\n    description = {\n        [\"en\"] = \"Filters data points to only include those at or after the specified cutoff time.\",\n        [\"de\"] = \"Filtert Datenpunkte, um nur diejenigen ab dem angegebenen Grenzwert einzuschließen.\",\n        [\"es\"] = \"Filtra puntos de datos para incluir solo aquellos en o después del límite especificado.\",\n        [\"fr\"] = \"Filtre les points de données pour n'inclure que ceux à partir de la limite spécifiée.\",\n    },\n    config = {\n        instant {\n            id = \"cutoff\",\n            name = \"_cutoff\",\n            default = now - (30 * core.DURATION.DAY),  -- 30 days ago\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local cutoff = config and config.cutoff or error(\"Cutoff configuration is required\")\n\n        return function()\n            while true do\n                local data_point = source.dp()\n                if not data_point then\n                    return nil\n                end\n\n                -- Only return data points at or after the cutoff\n                if data_point.timestamp >= cutoff then\n                    return data_point\n                end\n                -- Otherwise, skip this data point and continue to the next\n            end\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["filter-after-last"]={
      script="-- Lua Function to filter data points after a reference point\n-- Outputs all data points from the first source that come after the last point in the second source\n\nreturn {\n\9-- Configuration metadata\n\9id = \"filter-after-last\",\n\9version = \"1.0.0\",\n\9inputCount = 2,\n\9categories = {\"_filter\"},\n\9title = {\n\9\9[\"en\"] = \"Filter After Last\",\n\9\9[\"de\"] = \"Filtern nach Letztem\",\n\9\9[\"es\"] = \"Filtrar después del último\",\n\9\9[\"fr\"] = \"Filtrer après le dernier\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nFilters data points from the first input source to only include those that occur after the last data point in the second input source.\n\nThis is useful for filtering data based on a reference event or timestamp from another tracker.\n]],\n\9\9[\"de\"] = [[\nFiltert Datenpunkte aus der ersten Eingabequelle, um nur diejenigen einzuschließen, die nach dem letzten Datenpunkt in der zweiten Eingabequelle auftreten.\n\nDies ist nützlich zum Filtern von Daten basierend auf einem Referenzereignis oder Zeitstempel von einem anderen Tracker.\n]],\n\9\9[\"es\"] = [[\nFiltra puntos de datos de la primera fuente de entrada para incluir solo aquellos que ocurren después del último punto de datos en la segunda fuente de entrada.\n\nEsto es útil para filtrar datos basados en un evento de referencia o marca de tiempo de otro rastreador.\n]],\n\9\9[\"fr\"] = [[\nFiltre les points de données de la première source d'entrée pour n'inclure que ceux qui se produisent après le dernier point de données de la deuxième source d'entrée.\n\nCeci est utile pour filtrer les données basées sur un événement de référence ou un horodatage d'un autre tracker.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(sources, config)\n\9\9local source1 = sources[1]\n\9\9local source2 = sources[2]\n\9\9local cutoff_timestamp = nil\n\n\9\9return function()\n\9\9\9-- Initialize cutoff on first call\n\9\9\9if cutoff_timestamp == nil then\n\9\9\9\9local reference_point = source2.dp()\n\9\9\9\9cutoff_timestamp = reference_point and reference_point.timestamp\n\9\9\9end\n\n\9\9\9-- Get next point from source1 and check if it's after cutoff\n\9\9\9local data_point = source1.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Data points are in reverse chronological order, so \"after\" means greater timestamp\n\9\9\9if not cutoff_timestamp or data_point.timestamp > cutoff_timestamp then\n\9\9\9\9return data_point\n\9\9\9end\n\n\9\9\9-- If the data point is not after the cutoff we're done\n\9\9\9return nil\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["filter-by-label"]={
      script="-- Example Lua Function with Input Count and Configuration\n-- This function filters data points by label\n\nlocal tng_config = require(\"tng.config\")\nlocal text = tng_config.text\nlocal checkbox = tng_config.checkbox\n\nlocal function match(data_point, filter_label, case_sensitive, match_exactly)\n    if filter_label == nil then\n        return true\n    end\n\n    local data_label = data_point.label\n    if not data_label then return false end\n\n    -- Apply case sensitivity\n    if not case_sensitive then\n        data_label = string.lower(data_label)\n        filter_label = string.lower(filter_label)\n    end\n\n    -- Apply matching mode\n    if match_exactly then\n        return data_label == filter_label\n    else\n        return string.find(data_label, filter_label, 1, true) ~= nil\n    end\nend\n\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-by-label\",\n    version = \"1.0.1\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter by Label\",\n        [\"de\"] = \"Filtern nach Etikett\",\n        [\"es\"] = \"Filtrar por Etiqueta\",\n        [\"fr\"] = \"Filtrer par Étiquette\"\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by their label field. Only data points matching the filter criteria will pass through.\n\nConfiguration:\n- **Filter Label**: The text to search for in labels\n- **Case Sensitive**: Match case exactly (default: false)\n- **Match Exactly**: Require exact match instead of substring (default: false)\n- **Invert**: Keep data points that DON'T match instead (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach ihrem Label-Feld. Nur Datenpunkte, die den Filterkriterien entsprechen, werden durchgelassen.\n\nKonfiguration:\n- **Filter-Label**: Der Text, nach dem in Labels gesucht werden soll\n- **Groß-/Kleinschreibung beachten**: Groß-/Kleinschreibung exakt beachten (Standard: false)\n- **Exakt übereinstimmen**: Exakte Übereinstimmung statt Teilstring erforderlich (Standard: false)\n- **Invertieren**: Datenpunkte behalten, die NICHT übereinstimmen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por su campo de etiqueta. Solo los puntos de datos que coincidan con los criterios del filtro pasarán.\n\nConfiguración:\n- **Filtrar Etiqueta**: El texto a buscar en las etiquetas\n- **Sensible a Mayúsculas**: Coincidir exactamente con mayúsculas y minúsculas (predeterminado: false)\n- **Coincidir Exactamente**: Requerir coincidencia exacta en lugar de subcadena (predeterminado: false)\n- **Invertir**: Mantener puntos de datos que NO coincidan (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par leur champ d'étiquette. Seuls les points de données correspondant aux critères du filtre passeront.\n\nConfiguration:\n- **Filtrer l'Étiquette**: Le texte à rechercher dans les étiquettes\n- **Sensible à la Casse**: Correspondance exacte de la casse (par défaut: false)\n- **Correspondance Exacte**: Nécessite une correspondance exacte au lieu d'une sous-chaîne (par défaut: false)\n- **Inverser**: Conserver les points de données qui NE correspondent PAS (par défaut: false)\n]]\n    },\n    config = {\n        text {\n            id = \"filter_label\",\n            name = {\n                [\"en\"] = \"Filter Label\",\n                [\"de\"] = \"Filter-Label\",\n                [\"es\"] = \"Filtrar Etiqueta\",\n                [\"fr\"] = \"Filtrer l'Étiquette\"\n            }\n        },\n        checkbox {\n            id = \"case_sensitive\",\n            name = \"_case_sensitive\",\n        },\n        checkbox {\n            id = \"match_exactly\",\n            name = \"_match_exactly\",\n        },\n        checkbox {\n            id = \"invert\",\n            name = {\n                [\"en\"] = \"Invert\",\n                [\"de\"] = \"Invertieren\",\n                [\"es\"] = \"Invertir\",\n                [\"fr\"] = \"Inverser\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local filter_label = config and config.filter_label\n        local case_sensitive = config and config.case_sensitive or false\n        local match_exactly = config and config.match_exactly or false\n        local invert = config and config.invert or false\n\n        return function()\n            local data_point = source.dp()\n            local should_match = not invert\n            while data_point and (match(data_point, filter_label, case_sensitive, match_exactly) ~= should_match) do\n                data_point = source.dp()\n            end\n            return data_point\n        end\n    end\n}\n",
      version="1.0.1"
    },
    ["filter-by-note"]={
      script="-- Lua Function to filter data points by note\n-- This function filters data points by note\n\nlocal tng_config = require(\"tng.config\")\nlocal text = tng_config.text\nlocal checkbox = tng_config.checkbox\n\nlocal function match(data_point, filter_note, case_sensitive, match_exactly)\n    if filter_note == nil then\n        return true\n    end\n\n    local data_note = data_point.note\n    if not data_note then return false end\n\n    -- Apply case sensitivity\n    if not case_sensitive then\n        data_note = string.lower(data_note)\n        filter_note = string.lower(filter_note)\n    end\n\n    -- Apply matching mode\n    if match_exactly then\n        return data_note == filter_note\n    else\n        return string.find(data_note, filter_note, 1, true) ~= nil\n    end\nend\n\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-by-note\",\n    version = \"1.0.1\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter by Note\",\n        [\"de\"] = \"Filtern nach Notiz\",\n        [\"es\"] = \"Filtrar por Nota\",\n        [\"fr\"] = \"Filtrer par Note\"\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by their note field. Only data points matching the filter criteria will pass through.\n\nConfiguration:\n- **Filter Note**: The text to search for in notes\n- **Case Sensitive**: Match case exactly (default: false)\n- **Match Exactly**: Require exact match instead of substring (default: false)\n- **Invert**: Keep data points that DON'T match instead (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach ihrem Notiz-Feld. Nur Datenpunkte, die den Filterkriterien entsprechen, werden durchgelassen.\n\nKonfiguration:\n- **Filter-Notiz**: Der Text, nach dem in Notizen gesucht werden soll\n- **Groß-/Kleinschreibung beachten**: Groß-/Kleinschreibung exakt beachten (Standard: false)\n- **Exakt übereinstimmen**: Exakte Übereinstimmung statt Teilstring erforderlich (Standard: false)\n- **Invertieren**: Datenpunkte behalten, die NICHT übereinstimmen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por su campo de nota. Solo los puntos de datos que coincidan con los criterios del filtro pasarán.\n\nConfiguración:\n- **Filtrar Nota**: El texto a buscar en las notas\n- **Sensible a Mayúsculas**: Coincidir exactamente con mayúsculas y minúsculas (predeterminado: false)\n- **Coincidir Exactamente**: Requerir coincidencia exacta en lugar de subcadena (predeterminado: false)\n- **Invertir**: Mantener puntos de datos que NO coincidan (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par leur champ de note. Seuls les points de données correspondant aux critères du filtre passeront.\n\nConfiguration:\n- **Filtrer la Note**: Le texte à rechercher dans les notes\n- **Sensible à la Casse**: Correspondance exacte de la casse (par défaut: false)\n- **Correspondance Exacte**: Nécessite une correspondance exacte au lieu d'une sous-chaîne (par défaut: false)\n- **Inverser**: Conserver les points de données qui NE correspondent PAS (par défaut: false)\n]]\n    },\n    config = {\n        text {\n            id = \"filter_note\",\n            name = {\n                [\"en\"] = \"Filter Note\",\n                [\"de\"] = \"Filter-Notiz\",\n                [\"es\"] = \"Filtrar Nota\",\n                [\"fr\"] = \"Filtrer la Note\"\n            }\n        },\n        checkbox {\n            id = \"case_sensitive\",\n            name = \"_case_sensitive\",\n        },\n        checkbox {\n            id = \"match_exactly\",\n            name = \"_match_exactly\",\n        },\n        checkbox {\n            id = \"invert\",\n            name = {\n                [\"en\"] = \"Invert\",\n                [\"de\"] = \"Invertieren\",\n                [\"es\"] = \"Invertir\",\n                [\"fr\"] = \"Inverser\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local filter_note = config and config.filter_note\n        local case_sensitive = config and config.case_sensitive or false\n        local match_exactly = config and config.match_exactly or false\n        local invert = config and config.invert or false\n\n        return function()\n            local data_point = source.dp()\n            local should_match = not invert\n            while data_point and (match(data_point, filter_note, case_sensitive, match_exactly) ~= should_match) do\n                data_point = source.dp()\n            end\n            return data_point\n        end\n    end\n}\n",
      version="1.0.1"
    },
    ["filter-greater-than"]={
      script="-- Lua Function to filter data points by value (greater than threshold)\n-- Only passes through data points with values greater than a threshold\n\nlocal tng_config = require(\"tng.config\")\nlocal number = tng_config.number\nlocal checkbox = tng_config.checkbox\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-greater-than\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter Greater Than\",\n        [\"de\"] = \"Filtern größer als\",\n        [\"es\"] = \"Filtrar mayor que\",\n        [\"fr\"] = \"Filtrer supérieur à\",\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by value. Only data points with values greater than the threshold will pass through.\n\nConfiguration:\n- **Threshold**: The minimum value (exclusive by default)\n- **Include Equal**: Also include values equal to the threshold (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach Wert. Nur Datenpunkte mit Werten größer als der Schwellenwert werden durchgelassen.\n\nKonfiguration:\n- **Schwellenwert**: Der Mindestwert (standardmäßig exklusiv)\n- **Gleich einschließen**: Werte gleich dem Schwellenwert auch einschließen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por valor. Solo los puntos de datos con valores mayores que el umbral pasarán.\n\nConfiguración:\n- **Umbral**: El valor mínimo (exclusivo por defecto)\n- **Incluir igual**: También incluir valores iguales al umbral (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par valeur. Seuls les points de données avec des valeurs supérieures au seuil passeront.\n\nConfiguration:\n- **Seuil**: La valeur minimale (exclusive par défaut)\n- **Inclure égal**: Inclure également les valeurs égales au seuil (par défaut: false)\n]],\n    },\n    config = {\n        number {\n            id = \"threshold\",\n            name = {\n                [\"en\"] = \"Threshold\",\n                [\"de\"] = \"Schwellenwert\",\n                [\"es\"] = \"Umbral\",\n                [\"fr\"] = \"Seuil\",\n            },\n        },\n        checkbox {\n            id = \"include_equal\",\n            name = {\n                [\"en\"] = \"Include Equal\",\n                [\"de\"] = \"Gleich einschließen\",\n                [\"es\"] = \"Incluir igual\",\n                [\"fr\"] = \"Inclure égal\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local threshold = config and config.threshold or 0.0\n        local include_equal = config and config.include_equal or false\n\n        return function()\n            while true do\n                local data_point = source.dp()\n                if not data_point then\n                    return nil\n                end\n\n                local passes\n                if include_equal then\n                    passes = data_point.value >= threshold\n                else\n                    passes = data_point.value > threshold\n                end\n\n                if passes then\n                    return data_point\n                end\n            end\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["filter-less-than"]={
      script="-- Lua Function to filter data points by value (less than threshold)\n-- Only passes through data points with values less than a threshold\n\nlocal tng_config = require(\"tng.config\")\nlocal number = tng_config.number\nlocal checkbox = tng_config.checkbox\n\nreturn {\n    -- Configuration metadata\n    id = \"filter-less-than\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_filter\"},\n    title = {\n        [\"en\"] = \"Filter Less Than\",\n        [\"de\"] = \"Filtern kleiner als\",\n        [\"es\"] = \"Filtrar menor que\",\n        [\"fr\"] = \"Filtrer inférieur à\",\n    },\n    description = {\n        [\"en\"] = [[\nFilters data points by value. Only data points with values less than the threshold will pass through.\n\nConfiguration:\n- **Threshold**: The maximum value (exclusive by default)\n- **Include Equal**: Also include values equal to the threshold (default: false)\n]],\n        [\"de\"] = [[\nFiltert Datenpunkte nach Wert. Nur Datenpunkte mit Werten kleiner als der Schwellenwert werden durchgelassen.\n\nKonfiguration:\n- **Schwellenwert**: Der Maximalwert (standardmäßig exklusiv)\n- **Gleich einschließen**: Werte gleich dem Schwellenwert auch einschließen (Standard: false)\n]],\n        [\"es\"] = [[\nFiltra puntos de datos por valor. Solo los puntos de datos con valores menores que el umbral pasarán.\n\nConfiguración:\n- **Umbral**: El valor máximo (exclusivo por defecto)\n- **Incluir igual**: También incluir valores iguales al umbral (predeterminado: false)\n]],\n        [\"fr\"] = [[\nFiltre les points de données par valeur. Seuls les points de données avec des valeurs inférieures au seuil passeront.\n\nConfiguration:\n- **Seuil**: La valeur maximale (exclusive par défaut)\n- **Inclure égal**: Inclure également les valeurs égales au seuil (par défaut: false)\n]],\n    },\n    config = {\n        number {\n            id = \"threshold\",\n            name = {\n                [\"en\"] = \"Threshold\",\n                [\"de\"] = \"Schwellenwert\",\n                [\"es\"] = \"Umbral\",\n                [\"fr\"] = \"Seuil\",\n            },\n        },\n        checkbox {\n            id = \"include_equal\",\n            name = {\n                [\"en\"] = \"Include Equal\",\n                [\"de\"] = \"Gleich einschließen\",\n                [\"es\"] = \"Incluir igual\",\n                [\"fr\"] = \"Inclure égal\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local threshold = config and config.threshold or 0.0\n        local include_equal = config and config.include_equal or false\n\n        return function()\n            while true do\n                local data_point = source.dp()\n                if not data_point then\n                    return nil\n                end\n\n                local passes\n                if include_equal then\n                    passes = data_point.value <= threshold\n                else\n                    passes = data_point.value < threshold\n                end\n\n                if passes then\n                    return data_point\n                end\n            end\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    floor={
      script="-- Lua Function to floor values\n-- Rounds each data point's value down to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"floor\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Floor\",\n\9\9[\"de\"] = \"Abrunden\",\n\9\9[\"es\"] = \"Piso\",\n\9\9[\"fr\"] = \"Plancher\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nRounds each data point's value down to the nearest multiple of a specified number.\n\nConfiguration:\n- **Nearest**: Round down to the nearest multiple of this number (default: 1.0)\n]],\n\9\9[\"de\"] = [[\nRundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl ab.\n\nKonfiguration:\n- **Nächste**: Auf das nächste Vielfache dieser Zahl abrunden (Standard: 1.0)\n]],\n\9\9[\"es\"] = [[\nRedondea hacia abajo el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n- **Más cercano**: Redondear hacia abajo al múltiplo más cercano de este número (predeterminado: 1.0)\n]],\n\9\9[\"fr\"] = [[\nArrondit vers le bas la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n- **Plus proche**: Arrondir vers le bas au multiple le plus proche de ce nombre (par défaut: 1.0)\n]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Floor to nearest multiple\n\9\9\9data_point.value = math.floor(data_point.value / nearest) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    multiply={
      script="-- Lua Function to multiply data point values by a configurable number\n-- This function multiplies all incoming data point values by a specified multiplier\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"multiply\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Multiply Values\",\n        [\"de\"] = \"Werte multiplizieren\",\n        [\"es\"] = \"Multiplicar Valores\",\n        [\"fr\"] = \"Multiplier les Valeurs\"\n    },\n    description = {\n        [\"en\"] = [[\nMultiplies all incoming data point values by a specified multiplier.\n\nConfiguration:\n- **Multiplier**: The number to multiply all values by (default: 1.0)\n]],\n        [\"de\"] = [[\nMultipliziert alle eingehenden Datenpunktwerte mit einem bestimmten Multiplikator.\n\nKonfiguration:\n- **Multiplikator**: Die Zahl, mit der alle Werte multipliziert werden (Standard: 1.0)\n]],\n        [\"es\"] = [[\nMultiplica todos los valores de puntos de datos entrantes por un multiplicador especificado.\n\nConfiguración:\n- **Multiplicador**: El número por el cual multiplicar todos los valores (predeterminado: 1.0)\n]],\n        [\"fr\"] = [[\nMultiplie toutes les valeurs de points de données entrantes par un multiplicateur spécifié.\n\nConfiguration:\n- **Multiplicateur**: Le nombre par lequel multiplier toutes les valeurs (par défaut: 1.0)\n]]\n    },\n    config = {\n        number {\n            id = \"multiplier\",\n            name = {\n                [\"en\"] = \"Multiplier\",\n                [\"de\"] = \"Multiplikator\",\n                [\"es\"] = \"Multiplicador\",\n                [\"fr\"] = \"Multiplicateur\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local multiplier = config and config.multiplier or 1.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value * multiplier\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["offset-value"]={
      script="-- Lua Function to offset data point values by a configurable number\n-- This function adds a constant offset to all incoming data point values\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"offset-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_arithmetic\"},\n    title = {\n        [\"en\"] = \"Offset Value\",\n        [\"de\"] = \"Wert verschieben\",\n        [\"es\"] = \"Desplazar Valor\",\n        [\"fr\"] = \"Décaler la Valeur\"\n    },\n    description = {\n        [\"en\"] = [[\nAdds a constant offset to all incoming data point values.\n\nConfiguration:\n- **Offset**: The number to add to all values (default: 0.0). Use negative values to subtract.\n]],\n        [\"de\"] = [[\nFügt allen eingehenden Datenpunktwerten einen konstanten Offset hinzu.\n\nKonfiguration:\n- **Offset**: Die Zahl, die zu allen Werten addiert wird (Standard: 0.0). Verwenden Sie negative Werte zum Subtrahieren.\n]],\n        [\"es\"] = [[\nAñade un desplazamiento constante a todos los valores de puntos de datos entrantes.\n\nConfiguración:\n- **Desplazamiento**: El número a añadir a todos los valores (predeterminado: 0.0). Use valores negativos para restar.\n]],\n        [\"fr\"] = [[\nAjoute un décalage constant à toutes les valeurs de points de données entrantes.\n\nConfiguration:\n- **Décalage**: Le nombre à ajouter à toutes les valeurs (par défaut: 0.0). Utilisez des valeurs négatives pour soustraire.\n]]\n    },\n    config = {\n        number {\n            id = \"offset\",\n            default = 0.0,\n            name = {\n                [\"en\"] = \"Offset\",\n                [\"de\"] = \"Offset\",\n                [\"es\"] = \"Desplazamiento\",\n                [\"fr\"] = \"Décalage\"\n            }\n        }\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local offset = config and config.offset or 0.0\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then return nil end\n\n            data_point.value = data_point.value + offset\n\n            return data_point\n        end\n    end\n}\n",
      version="1.0.0"
    },
    ["override-label"]={
      script="-- Lua Function to override the label of all data points with a configurable string\n-- This function sets all incoming data point labels to a specified value\n\nlocal text = require(\"tng.config\").text\n\nreturn {\n    -- Configuration metadata\n    id = \"override-label\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Label\",\n        [\"de\"] = \"Label überschreiben\",\n        [\"es\"] = \"Sobrescribir Etiqueta\",\n        [\"fr\"] = \"Remplacer l'Étiquette\",\n    },\n    description = {\n        [\"en\"] = [[\nSets all incoming data point labels to a specified value\n]],\n        [\"de\"] = [[\nSetzt alle eingehenden Datenpunkt-Labels auf einen bestimmten Wert\n]],\n        [\"es\"] = [[\nEstablece todas las etiquetas de puntos de datos entrantes en un valor especificado\n]],\n        [\"fr\"] = [[\nDéfinit toutes les étiquettes de points de données entrantes sur une valeur spécifiée\n]],\n    },\n    config = {\n        text {\n            id = \"new_label\",\n            name = {\n                [\"en\"] = \"New Label\",\n                [\"de\"] = \"Neues Label\",\n                [\"es\"] = \"Nueva Etiqueta\",\n                [\"fr\"] = \"Nouvelle Étiquette\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_label = config and config.new_label\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_label then\n                return data_point\n            end\n            data_point.label = new_label\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["override-note"]={
      script="-- Lua Function to override the note of all data points with a configurable string\n-- This function sets all incoming data point notes to a specified value\n\nlocal text = require(\"tng.config\").text\n\nreturn {\n    -- Configuration metadata\n    id = \"override-note\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Note\",\n        [\"de\"] = \"Notiz überschreiben\",\n        [\"es\"] = \"Sobrescribir Nota\",\n        [\"fr\"] = \"Remplacer la Note\",\n    },\n    description = {\n        [\"en\"] = [[\nSets all incoming data point notes to a specified value\n]],\n        [\"de\"] = [[\nSetzt alle eingehenden Datenpunkt-Notizen auf einen bestimmten Wert\n]],\n        [\"es\"] = [[\nEstablece todas las notas de puntos de datos entrantes en un valor especificado\n]],\n        [\"fr\"] = [[\nDéfinit toutes les notes de points de données entrantes sur une valeur spécifiée\n]],\n    },\n    config = {\n        text {\n            id = \"new_note\",\n            name = {\n                [\"en\"] = \"New Note\",\n                [\"de\"] = \"Neue Notiz\",\n                [\"es\"] = \"Nueva Nota\",\n                [\"fr\"] = \"Nouvelle Note\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_note = config and config.new_note\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_note then\n                return data_point\n            end\n            data_point.note = new_note\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["override-value"]={
      script="-- Lua Function to override the value of all data points with a configurable number\n-- This function sets all incoming data point values to a specified value\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n    -- Configuration metadata\n    id = \"override-value\",\n    version = \"1.0.0\",\n    inputCount = 1,\n    categories = {\"_transform\"},\n    title = {\n        [\"en\"] = \"Override Value\",\n        [\"de\"] = \"Wert überschreiben\",\n        [\"es\"] = \"Sobrescribir Valor\",\n        [\"fr\"] = \"Remplacer la Valeur\",\n    },\n    description = {\n        [\"en\"] = [[\nSets all incoming data point values to a specified value\n]],\n        [\"de\"] = [[\nSetzt alle eingehenden Datenpunktwerte auf einen bestimmten Wert\n]],\n        [\"es\"] = [[\nEstablece todos los valores de puntos de datos entrantes en un valor especificado\n]],\n        [\"fr\"] = [[\nDéfinit toutes les valeurs de points de données entrantes sur une valeur spécifiée\n]],\n    },\n    config = {\n        number {\n            id = \"new_value\",\n            name = {\n                [\"en\"] = \"New Value\",\n                [\"de\"] = \"Neuer Wert\",\n                [\"es\"] = \"Nuevo Valor\",\n                [\"fr\"] = \"Nouvelle Valeur\",\n            },\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local new_value = config and config.new_value\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            if not new_value then\n                return data_point\n            end\n            data_point.value = new_value\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.0.0"
    },
    ["pair-and-operate"]={
      script="-- Lua Function to pair the data points of two input sources and perform\n-- an operation on their values (addition, subtraction, multiplication, or division).\nlocal duration = require(\"tng.config\").duration\nlocal enum = require(\"tng.config\").enum\nlocal core = require(\"tng.core\")\n\nreturn {\n  -- Configuration metadata\n  id = \"pair-and-operate\",\n  version = \"1.0.2\",\n  inputCount = 2,\n  categories = { \"_transform\" },\n  title = {\n    [\"en\"] = \"Pair and Operate\",\n    [\"de\"] = \"Paaren und Operieren\",\n    [\"es\"] = \"Emparejar y Operar\",\n    [\"fr\"] = \"Apparier et Opérer\",\n  },\n  description = {\n    [\"en\"] = [[\nPairs each data point in the first data source with the corresponding data point in the second data source and performs a specified operation (addition, subtraction, multiplication, or division) on their values. The pair for each data point is the first data point that falls within the given time threshold. Configuration:\n\n- **Time Threshold:** The maximum duration between data points in the two sources to be considered a pair.\n- **Operation:** The mathematical operation to perform on the paired data point values (addition, subtraction, multiplication, or division).\n- **On Missing:** Specifies the behavior when a data point in the first source does not have a corresponding data point in the second source within the given time threshold. Options include:\n  - **Skip:** Do not output anything for that data point.\n  - **Pass Through:** Output the original data point from the first source without modification.\n\n> **Note:** Division by zero is invalid and considered as missing data. The On Missing configuration will determine how such cases are handled.\n]],\n    [\"de\"] = [[\nPaart jeden Datenpunkt in der ersten Datenquelle mit dem entsprechenden Datenpunkt in der zweiten Datenquelle und führt eine bestimmte Operation (Addition, Subtraktion, Multiplikation oder Division) mit ihren Werten durch. Das Paar für jeden Datenpunkt ist der erste Datenpunkt, der innerhalb des gegebenen Zeitschwellwerts liegt. Konfiguration:\n\n- **Zeitschwellwert:** Die maximale Dauer zwischen Datenpunkten in den beiden Quellen, um als Paar betrachtet zu werden.\n- **Operation:** Die mathematische Operation, die mit den gepaarten Datenpunktwerten durchgeführt werden soll (Addition, Subtraktion, Multiplikation oder Division).\n- **Bei Fehlen:** Gibt das Verhalten an, wenn ein Datenpunkt in der ersten Quelle keinen entsprechenden Datenpunkt in der zweiten Quelle innerhalb des gegebenen Zeitschwellwerts hat. Optionen umfassen:\n  - **Überspringen:** Nichts für diesen Datenpunkt ausgeben.\n  - **Durchleiten:** Den ursprünglichen Datenpunkt aus der ersten Quelle ohne Änderung ausgeben.\n\n> **Hinweis:** Division durch Null ist ungültig und wird als fehlende Daten betrachtet. Die Konfiguration \"Bei Fehlen\" bestimmt, wie solche Fälle behandelt werden.\n]],\n    [\"es\"] = [[\nEmpareja cada punto de datos en la primera fuente de datos con el punto de datos correspondiente en la segunda fuente de datos y realiza una operación específica (suma, resta, multiplicación o división) en sus valores. La pareja para cada punto de datos es el primer punto de datos que cae dentro del umbral de tiempo dado. Configuración:\n\n- **Umbral de Tiempo:** La duración máxima entre puntos de datos en las dos fuentes para ser considerados una pareja.\n- **Operación:** La operación matemática a realizar en los valores de puntos de datos emparejados (suma, resta, multiplicación o división).\n- **En Faltante:** Especifica el comportamiento cuando un punto de datos en la primera fuente no tiene un punto de datos correspondiente en la segunda fuente dentro del umbral de tiempo dado. Las opciones incluyen:\n  - **Omitir:** No generar nada para ese punto de datos.\n  - **Pasar Sin Cambios:** Generar el punto de datos original de la primera fuente sin modificación.\n\n> **Nota:** La división por cero es inválida y se considera como datos faltantes. La configuración \"En Faltante\" determinará cómo se manejan tales casos.\n]],\n    [\"fr\"] = [[\nApparie chaque point de données dans la première source de données avec le point de données correspondant dans la deuxième source de données et effectue une opération spécifiée (addition, soustraction, multiplication ou division) sur leurs valeurs. La paire pour chaque point de données est le premier point de données qui tombe dans le seuil de temps donné. Configuration:\n\n- **Seuil de Temps:** La durée maximale entre les points de données dans les deux sources pour être considérés comme une paire.\n- **Opération:** L'opération mathématique à effectuer sur les valeurs des points de données appariés (addition, soustraction, multiplication ou division).\n- **En Cas de Manque:** Spécifie le comportement lorsqu'un point de données dans la première source n'a pas de point de données correspondant dans la deuxième source dans le seuil de temps donné. Les options incluent:\n  - **Ignorer:** Ne rien générer pour ce point de données.\n  - **Laisser Passer:** Générer le point de données original de la première source sans modification.\n\n> **Note:** La division par zéro est invalide et considérée comme des données manquantes. La configuration \"En Cas de Manque\" déterminera comment de tels cas sont traités.\n]],\n  },\n  config = {\n    duration {\n      id = \"threshold\",\n      name = \"_time_threshold\",\n      default = core.DURATION.MINUTE,\n    },\n    enum {\n      id = \"operation\",\n      name = \"_operation\",\n      options = { \"_addition\", \"_subtraction\", \"_multiplication\", \"_division\" },\n      default = \"_addition\",\n    },\n    enum {\n      id = \"on_missing\",\n      name = \"_on_missing\",\n      options = { \"_skip\", \"_pass_through\" },\n      default = \"_skip\",\n    },\n  },\n\n  -- Generator function\n  generator = function(sources, config)\n    local threshold = config.threshold or error(\"Missing 'threshold' in config\")\n    local operation = config.operation or error(\"Missing 'operation' in config\")\n    local on_missing = config.on_missing or error(\"Missing 'on_missing' in config\")\n    local source1 = sources[1] or error(\"Missing first data source\")\n    local source2 = sources[2] or error(\"Missing second data source\")\n\n    local source2_carry = nil\n\n    return function()\n      local result_dp = nil\n\n      while true do\n        local data_point = source1.dp()\n        if not data_point then\n          return nil\n        end\n\n        result_dp = data_point\n\n        local time1 = data_point.timestamp\n        local paired_dp = nil\n        while true do\n          local candidate_dp = source2_carry or source2.dp()\n          source2_carry = nil\n          if not candidate_dp then\n            break\n          end\n\n          local time2 = candidate_dp.timestamp\n          local time_diff = math.abs(time1 - time2)\n\n          if time_diff <= threshold then\n            paired_dp = candidate_dp\n            break\n          elseif time2 < time1 - threshold then\n            source2_carry = candidate_dp\n            break\n          end\n        end\n\n\n        if paired_dp then\n          if operation == \"_addition\" then\n            result_dp.value = data_point.value + paired_dp.value\n          elseif operation == \"_subtraction\" then\n            result_dp.value = data_point.value - paired_dp.value\n          elseif operation == \"_multiplication\" then\n            result_dp.value = data_point.value * paired_dp.value\n          elseif operation == \"_division\" then\n            if paired_dp.value == 0 then\n              if on_missing == \"_skip\" then\n                result_dp = nil\n              end\n            else\n              result_dp.value = data_point.value / paired_dp.value\n            end\n          else\n            error(\"invalid operation: \" .. operation)\n          end\n        elseif on_missing == \"_pass_through\" then\n          break\n        else\n          result_dp = nil\n        end\n\n        if result_dp ~= nil then break end\n      end\n\n      return result_dp\n    end\n  end,\n}\n",
      version="1.0.2"
    },
    ["periodic-data-points"]={
      script="-- Lua Function to generate periodic data points at regular intervals\n-- This function creates data points with value=1 at deterministic timestamps\n\nlocal core = require(\"tng.core\")\nlocal enum = require(\"tng.config\").enum\nlocal uint = require(\"tng.config\").uint\nlocal instant = require(\"tng.config\").instant\n\nlocal now_time = core.time()\nlocal now = now_time and now_time.timestamp or 0\n\nreturn {\n    -- Configuration metadata\n    id = \"periodic-data-points\",\n    version = \"1.1.1\",\n    inputCount = 0, -- This is a generator, not a transformer\n    categories = { \"_generators\" },\n    title = {\n        [\"en\"] = \"Periodic Data Points\",\n        [\"de\"] = \"Periodische Datenpunkte\",\n        [\"es\"] = \"Puntos de Datos Periódicos\",\n        [\"fr\"] = \"Points de Données Périodiques\",\n    },\n    description = {\n        [\"en\"] = [[\nGenerates data points with value=1 at regular intervals going back in time.\n\nConfiguration:\n- **Period**: Time period unit (Day, Week, Month, Year)\n- **Period Multiplier**: Generate data point every N periods (e.g., every 2 days)\n- **Cutoff**: Stop generating data points at this date/time\n\nGenerated data points will have:\n- value = 1.0\n- label = \"\" (empty)\n- note = \"\" (empty)]],\n        [\"de\"] = [[\nGeneriert Datenpunkte mit Wert=1 in regelmäßigen Abständen zurück in der Zeit.\n\nKonfiguration:\n- **Periode**: Zeitperiodeneinheit (Tag, Woche, Monat, Jahr)\n- **Periodenmultiplikator**: Datenpunkt alle N Perioden generieren (z.B. alle 2 Tage)\n- **Grenzwert**: Generierung bei diesem Datum/Zeit stoppen\n\nGenerierte Datenpunkte haben:\n- Wert = 1.0\n- Label = \"\" (leer)\n- Notiz = \"\" (leer)]],\n        [\"es\"] = [[\nGenera puntos de datos con valor=1 a intervalos regulares retrocediendo en el tiempo.\n\nConfiguración:\n- **Período**: Unidad de período de tiempo (Día, Semana, Mes, Año)\n- **Multiplicador de Período**: Generar punto de datos cada N períodos (ej. cada 2 días)\n- **Límite**: Detener generación de puntos de datos en esta fecha/hora\n\nLos puntos de datos generados tendrán:\n- valor = 1.0\n- etiqueta = \"\" (vacío)\n- nota = \"\" (vacío)]],\n        [\"fr\"] = [[\nGénère des points de données avec valeur=1 à intervalles réguliers en remontant dans le temps.\n\nConfiguration:\n- **Période**: Unité de période de temps (Jour, Semaine, Mois, Année)\n- **Multiplicateur de Période**: Générer un point de données tous les N périodes (ex. tous les 2 jours)\n- **Limite**: Arrêter la génération de points de données à cette date/heure\n\nLes points de données générés auront:\n- valeur = 1.0\n- étiquette = \"\" (vide)\n- note = \"\" (vide)]],\n    },\n    config = {\n        enum {\n            id = \"period\",\n            name = \"_period\",\n            options = { \"_day\", \"_week\", \"_month\", \"_year\" },\n            default = \"_day\",\n        },\n        uint {\n            id = \"period_multiplier\",\n            name = \"_period_multiplier\",\n            default = 1,\n        },\n        instant {\n            id = \"cutoff\",\n            name = \"_cutoff\",\n            default = now - (365 * core.DURATION.DAY),\n        },\n    },\n\n    -- Generator function\n    generator = function(_, config)\n        -- Parse configuration with defaults\n        local period_str = config and config.period or error(\"Period configuration is required\")\n        local period_multiplier = (config and config.period_multiplier) or 1\n        -- Don't allow 0 multiplier, fallback to 1\n        if period_multiplier == 0 then\n            period_multiplier = 1\n        end\n        local cutoff_timestamp = config and config.cutoff or error(\"Cutoff configuration is required\")\n\n        -- Map enum string to core.PERIOD constant\n        local period_map = {\n            [\"_day\"] = core.PERIOD.DAY,\n            [\"_week\"] = core.PERIOD.WEEK,\n            [\"_month\"] = core.PERIOD.MONTH,\n            [\"_year\"] = core.PERIOD.YEAR,\n        }\n        local period = period_map[period_str]\n\n        -- Get current time for comparison\n        local now = core.time().timestamp\n\n        -- If cutoff is in the future, no data points to generate\n        if cutoff_timestamp > now then\n            return function()\n                return nil\n            end\n        end\n\n        -- Estimate number of periods elapsed since anchor\n        local elapsed_ms = now - cutoff_timestamp\n        local estimated_periods\n        local period_duration_ms\n\n        if period == core.PERIOD.DAY then\n            period_duration_ms = period_multiplier * core.DURATION.DAY\n        elseif period == core.PERIOD.WEEK then\n            period_duration_ms = period_multiplier * core.DURATION.WEEK\n        elseif period == core.PERIOD.MONTH then\n            -- Average month length: 30.44 days\n            period_duration_ms = period_multiplier * 30.44 * core.DURATION.DAY\n        elseif period == core.PERIOD.YEAR then\n            -- Average year length: 365.25 days\n            period_duration_ms = period_multiplier * 365.25 * core.DURATION.DAY\n        else\n            error(\"Invalid period: \" .. tostring(period_str))\n        end\n\n        estimated_periods = math.floor(elapsed_ms / period_duration_ms)\n\n        local cutoff_date = core.date(cutoff_timestamp)\n\n        -- Jump close to now with one large shift\n        local candidate = core.shift(cutoff_date, period, estimated_periods * period_multiplier)\n\n        -- Fine-tune: shift forward until we pass \"now\"\n        while candidate.timestamp <= now do\n            candidate = core.shift(candidate, period, period_multiplier)\n        end\n\n        -- Back up one step to get the most recent data point <= now\n        local current = core.shift(candidate, period, -period_multiplier)\n\n        -- Return iterator function\n        return function()\n            -- Check if we've gone past the cutoff (with 1 second tolerance for millisecond precision loss)\n            if current.timestamp < cutoff_timestamp - 1000 then\n                return nil\n            end\n\n            -- Create data point at current timestamp\n            local data_point = {\n                timestamp = current.timestamp,\n                offset = current.offset,\n                value = 1.0,\n                label = \"\",\n                note = \"\",\n            }\n\n            -- Shift backwards by period * period_multiplier for next iteration\n            current = core.shift(current, period, -period_multiplier)\n\n            return data_point\n        end\n    end,\n}\n",
      version="1.1.1"
    },
    ["random-value"]={
      script="-- Lua Function to override data point values with random values\n-- This function replaces all incoming data point values with random numbers between min and max\n\nlocal number = require(\"tng.config\").number\nlocal uint = require(\"tng.config\").uint\nlocal core = require(\"tng.core\")\nlocal random = require(\"tng.random\")\n\nlocal now = core.time()\nlocal default_seed = now and now.timestamp or 0\n\nreturn {\n    -- Configuration metadata\n    id = \"random-value\",\n    version = \"2.0.0\",\n    inputCount = 1,\n    categories = { \"_randomisers\" },\n    title = {\n        [\"en\"] = \"Random Value\",\n        [\"de\"] = \"Zufälliger Wert\",\n        [\"es\"] = \"Valor Aleatorio\",\n        [\"fr\"] = \"Valeur Aléatoire\",\n    },\n    description = {\n        [\"en\"] = [[\nReplaces all incoming data point values with random numbers between min and max.\n\nConfiguration:\n- **Min Value**: The minimum value for random generation\n- **Max Value**: The maximum value for random generation\n- **Seed**: Random seed for reproducible results (defaults to current UTC timestamp)\n\nThe function automatically swaps min and max if max is smaller than min.]],\n        [\"de\"] = [[\nErsetzt alle eingehenden Datenpunktwerte durch Zufallszahlen zwischen Min und Max.\n\nKonfiguration:\n- **Minimalwert**: Der Minimalwert für die Zufallsgenerierung\n- **Maximalwert**: Der Maximalwert für die Zufallsgenerierung\n- **Seed**: Zufalls-Seed für reproduzierbare Ergebnisse (Standard: aktueller UTC-Zeitstempel)\n\nDie Funktion tauscht automatisch Min und Max, wenn Max kleiner als Min ist.]],\n        [\"es\"] = [[\nReemplaza todos los valores de puntos de datos entrantes con números aleatorios entre mín y máx.\n\nConfiguración:\n- **Valor Mínimo**: El valor mínimo para la generación aleatoria\n- **Valor Máximo**: El valor máximo para la generación aleatoria\n- **Semilla**: Semilla aleatoria para resultados reproducibles (predeterminado: marca de tiempo UTC actual)\n\nLa función intercambia automáticamente mín y máx si máx es menor que mín.]],\n        [\"fr\"] = [[\nRemplace toutes les valeurs de points de données entrantes par des nombres aléatoires entre min et max.\n\nConfiguration:\n- **Valeur Minimale**: La valeur minimale pour la génération aléatoire\n- **Valeur Maximale**: La valeur maximale pour la génération aléatoire\n- **Graine**: Graine aléatoire pour des résultats reproductibles (par défaut: horodatage UTC actuel)\n\nLa fonction échange automatiquement min et max si max est inférieur à min.]],\n    },\n    config = {\n        number {\n            id = \"min_value\",\n            name = \"_min_value\",\n            default = 0.0,\n        },\n        number {\n            id = \"max_value\",\n            name = \"_max_value\",\n            default = 1.0,\n        },\n        uint {\n            id = \"seed\",\n            name = \"_seed\",\n            default = default_seed,\n        },\n    },\n\n    -- Generator function\n    generator = function(source, config)\n        local min_val = config and config.min_value or 0.0\n        local max_val = config and config.max_value or 1.0\n        local seed = config and config.seed or core.time().timestamp\n\n        -- Ensure min is always the smaller value\n        if min_val > max_val then\n            min_val, max_val = max_val, min_val\n        end\n\n        return function()\n            local data_point = source.dp()\n            if not data_point then\n                return nil\n            end\n\n            -- Generate random value between min and max\n            local rng = random.new_seeded_random(seed, data_point.timestamp)\n            data_point.value = rng:next(min_val, max_val)\n\n            return data_point\n        end\n    end,\n}\n",
      version="2.0.0"
    },
    round={
      script="-- Lua Function to round values\n-- Rounds each data point's value to the nearest multiple of a specified number\n\nlocal number = require(\"tng.config\").number\n\nreturn {\n\9-- Configuration metadata\n\9id = \"round\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\"},\n\9title = {\n\9\9[\"en\"] = \"Round\",\n\9\9[\"de\"] = \"Runden\",\n\9\9[\"es\"] = \"Redondear\",\n\9\9[\"fr\"] = \"Arrondir\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nRounds each data point's value to the nearest multiple of a specified number.\n\nConfiguration:\n- **Nearest**: Round to the nearest multiple of this number (default: 1.0)\n]],\n\9\9[\"de\"] = [[\nRundet den Wert jedes Datenpunkts auf das nächste Vielfache einer angegebenen Zahl.\n\nKonfiguration:\n- **Nächste**: Auf das nächste Vielfache dieser Zahl runden (Standard: 1.0)\n]],\n\9\9[\"es\"] = [[\nRedondea el valor de cada punto de datos al múltiplo más cercano de un número especificado.\n\nConfiguración:\n- **Más cercano**: Redondear al múltiplo más cercano de este número (predeterminado: 1.0)\n]],\n\9\9[\"fr\"] = [[\nArrondit la valeur de chaque point de données au multiple le plus proche d'un nombre spécifié.\n\nConfiguration:\n- **Plus proche**: Arrondir au multiple le plus proche de ce nombre (par défaut: 1.0)\n]],\n\9},\n\9config = {\n\9\9number {\n\9\9\9id = \"nearest\",\n\9\9\9default = 1.0,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Nearest\",\n\9\9\9\9[\"de\"] = \"Nächste\",\n\9\9\9\9[\"es\"] = \"Más cercano\",\n\9\9\9\9[\"fr\"] = \"Plus proche\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local nearest = config and config.nearest or 1.0\n\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Round to nearest multiple\n\9\9\9data_point.value = math.floor((data_point.value / nearest) + 0.5) * nearest\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["swap-label-note"]={
      script="-- Lua Function to swap label and note fields\n-- Swaps the label and note of each data point\n\nreturn {\n\9-- Configuration metadata\n\9id = \"swap-label-note\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_transform\"},\n\9title = {\n\9\9[\"en\"] = \"Swap Label and Note\",\n\9\9[\"de\"] = \"Label und Notiz tauschen\",\n\9\9[\"es\"] = \"Intercambiar etiqueta y nota\",\n\9\9[\"fr\"] = \"Échanger étiquette et note\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSwaps the label and note fields of each data point.\n]],\n\9\9[\"de\"] = [[\nTauscht die Label- und Notizfelder jedes Datenpunkts aus.\n]],\n\9\9[\"es\"] = [[\nIntercambia los campos de etiqueta y nota de cada punto de datos.\n]],\n\9\9[\"fr\"] = [[\nÉchange les champs étiquette et note de chaque point de données.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Swap label and note\n\9\9\9local temp = data_point.label\n\9\9\9data_point.label = data_point.note\n\9\9\9data_point.note = temp\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["time-between"]={
      script="-- Lua Function to calculate time between data points\n-- Outputs the duration in seconds between each data point and the previous one\n\nlocal core = require(\"tng.core\")\nlocal checkbox = require(\"tng.config\").checkbox\n\nreturn {\n\9-- Configuration metadata\n\9id = \"time-between\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Time Between\",\n\9\9[\"de\"] = \"Zeit dazwischen\",\n\9\9[\"es\"] = \"Tiempo entre\",\n\9\9[\"fr\"] = \"Temps entre\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nCalculates the duration in seconds between each data point and the previous one. The output value is the time difference in seconds and can be treated as a duration.\n\nConfiguration:\n- **Include Time to First**: Include the time between now and the first data point (default: false)\n]],\n\9\9[\"de\"] = [[\nBerechnet die Dauer in Sekunden zwischen jedem Datenpunkt und dem vorherigen. Der Ausgabewert ist die Zeitdifferenz in Sekunden und kann als Dauer behandelt werden.\n\nKonfiguration:\n- **Zeit zum Ersten einschließen**: Die Zeit zwischen jetzt und dem ersten Datenpunkt einschließen (Standard: false)\n]],\n\9\9[\"es\"] = [[\nCalcula la duración en segundos entre cada punto de datos y el anterior. El valor de salida es la diferencia de tiempo en segundos y puede tratarse como una duración.\n\nConfiguración:\n- **Incluir tiempo al primero**: Incluir el tiempo entre ahora y el primer punto de datos (predeterminado: false)\n]],\n\9\9[\"fr\"] = [[\nCalcule la durée en secondes entre chaque point de données et le précédent. La valeur de sortie est la différence de temps en secondes et peut être traitée comme une durée.\n\nConfiguration:\n- **Inclure le temps jusqu'au premier**: Inclure le temps entre maintenant et le premier point de données (par défaut: false)\n]],\n\9},\n\9config = {\n\9\9checkbox {\n\9\9\9id = \"include_first\",\n\9\9\9default = false,\n\9\9\9name = {\n\9\9\9\9[\"en\"] = \"Include Time to First\",\n\9\9\9\9[\"de\"] = \"Zeit zum Ersten einschließen\",\n\9\9\9\9[\"es\"] = \"Incluir tiempo al primero\",\n\9\9\9\9[\"fr\"] = \"Inclure le temps jusqu'au premier\",\n\9\9\9},\n\9\9},\n\9},\n\n\9-- Generator function\n\9generator = function(source, config)\n\9\9local include_first = config and config.include_first or false\n\9\9local previous_point = nil\n\n\9\9return function()\n\9\9\9-- Initialize on first call\n\9\9\9if previous_point == nil then\n\9\9\9\9local first_point = source.dp()\n\9\9\9\9if not first_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\n\9\9\9\9previous_point = first_point\n\n\9\9\9\9if include_first then\n\9\9\9\9\9-- Return synthetic point with time from now to first\n\9\9\9\9\9local now = core.time().timestamp\n\9\9\9\9\9local duration_seconds = (now - first_point.timestamp) / 1000.0\n\n\9\9\9\9\9return {\n\9\9\9\9\9\9timestamp = first_point.timestamp,\n\9\9\9\9\9\9offset = first_point.offset,\n\9\9\9\9\9\9value = duration_seconds,\n\9\9\9\9\9\9label = \"\",\n\9\9\9\9\9\9note = \"\",\n\9\9\9\9\9}\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9-- Get next data point\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Calculate duration from previous to current\n\9\9\9local duration_seconds = (previous_point.timestamp - data_point.timestamp) / 1000.0\n\n\9\9\9-- Create output point using previous point's identity\n\9\9\9local output_point = {\n\9\9\9\9timestamp = previous_point.timestamp,\n\9\9\9\9offset = previous_point.offset,\n\9\9\9\9value = duration_seconds,\n\9\9\9\9label = previous_point.label,\n\9\9\9\9note = previous_point.note,\n\9\9\9}\n\n\9\9\9-- Update state for next iteration\n\9\9\9previous_point = data_point\n\n\9\9\9return output_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-difference"]={
      script="-- Lua Function to calculate value differences\n-- Outputs the difference between each data point's value and the next one\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-difference\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_arithmetic\", \"_transform\"},\n\9title = {\n\9\9[\"en\"] = \"Value Difference\",\n\9\9[\"de\"] = \"Wertdifferenz\",\n\9\9[\"es\"] = \"Diferencia de valor\",\n\9\9[\"fr\"] = \"Différence de valeur\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nCalculates the difference between each data point's value and the next one. Each output point has its original identity with the value set to the difference.\n]],\n\9\9[\"de\"] = [[\nBerechnet die Differenz zwischen dem Wert jedes Datenpunkts und dem nächsten. Jeder Ausgabepunkt hat seine ursprüngliche Identität mit dem Wert auf die Differenz gesetzt.\n]],\n\9\9[\"es\"] = [[\nCalcula la diferencia entre el valor de cada punto de datos y el siguiente. Cada punto de salida tiene su identidad original con el valor establecido en la diferencia.\n]],\n\9\9[\"fr\"] = [[\nCalcule la différence entre la valeur de chaque point de données et la suivante. Chaque point de sortie a son identité d'origine avec la valeur définie sur la différence.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9local next_point = nil\n\n\9\9return function()\n\9\9\9-- Pre-load the next point on first call\n\9\9\9if next_point == nil then\n\9\9\9\9next_point = source.dp()\n\9\9\9\9if not next_point then\n\9\9\9\9\9return nil\n\9\9\9\9end\n\9\9\9end\n\n\9\9\9-- Current point is what we'll output\n\9\9\9local current_point = next_point\n\n\9\9\9-- Pre-load the next point for the next iteration\n\9\9\9next_point = source.dp()\n\9\9\9if not next_point then\n\9\9\9\9-- No more points, can't calculate difference\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Calculate difference (current - next)\n\9\9\9local difference = current_point.value - next_point.value\n\n\9\9\9-- Return current point with difference as value\n\9\9\9return {\n\9\9\9\9timestamp = current_point.timestamp,\n\9\9\9\9offset = current_point.offset,\n\9\9\9\9value = difference,\n\9\9\9\9label = current_point.label,\n\9\9\9\9note = current_point.note,\n\9\9\9}\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-day-of-month"]={
      script="-- Lua Function to set value to day of month\n-- Sets each data point's value to its day of the month (1-31)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-day-of-month\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Day of Month\",\n\9\9[\"de\"] = \"Wert zu Tag des Monats\",\n\9\9[\"es\"] = \"Valor a día del mes\",\n\9\9[\"fr\"] = \"Valeur au jour du mois\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its day of the month (1-31).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seinen Tag des Monats (1-31).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su día del mes (1-31).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son jour du mois (1-31).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.day\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-day-of-week"]={
      script="-- Lua Function to set value to day of week\n-- Sets each data point's value to its day of the week (1-7, Monday is 1)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-day-of-week\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Day of Week\",\n\9\9[\"de\"] = \"Wert zu Wochentag\",\n\9\9[\"es\"] = \"Valor a día de la semana\",\n\9\9[\"fr\"] = \"Valeur au jour de la semaine\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its day of the week (1-7, where Monday is 1 and Sunday is 7).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seinen Wochentag (1-7, wobei Montag 1 und Sonntag 7 ist).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su día de la semana (1-7, donde lunes es 1 y domingo es 7).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son jour de la semaine (1-7, où lundi est 1 et dimanche est 7).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Get the date from the timestamp\n\9\9\9local date = core.date(data_point)\n\n\9\9\9-- Set value to day of week\n\9\9\9data_point.value = date.wday\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-hour-of-day"]={
      script="-- Lua Function to set value to hour of day\n-- Sets each data point's value to its hour of the day (0-23)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-hour-of-day\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Hour (0-23)\",\n\9\9[\"de\"] = \"Wert zu Stunde (0-23)\",\n\9\9[\"es\"] = \"Valor a hora (0-23)\",\n\9\9[\"fr\"] = \"Valeur à l'heure (0-23)\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its hour of the day (0-23).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seine Stunde des Tages (0-23).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su hora del día (0-23).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son heure du jour (0-23).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.hour or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-minute-of-hour"]={
      script="-- Lua Function to set value to minute of hour\n-- Sets each data point's value to its minute of the hour (0-59)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-minute-of-hour\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Minute of Hour\",\n\9\9[\"de\"] = \"Wert zu Minute der Stunde\",\n\9\9[\"es\"] = \"Valor a minuto de la hora\",\n\9\9[\"fr\"] = \"Valeur à la minute de l'heure\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its minute of the hour (0-59).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seine Minute der Stunde (0-59).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su minuto de la hora (0-59).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur sa minute de l'heure (0-59).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.min or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-month-of-year"]={
      script="-- Lua Function to set value to month of year\n-- Sets each data point's value to its month of the year (1-12)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-month-of-year\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Month of Year\",\n\9\9[\"de\"] = \"Wert zu Monat des Jahres\",\n\9\9[\"es\"] = \"Valor a mes del año\",\n\9\9[\"fr\"] = \"Valeur au mois de l'année\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its month of the year (1-12, where January is 1).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seinen Monat des Jahres (1-12, wobei Januar 1 ist).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su mes del año (1-12, donde enero es 1).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son mois de l'année (1-12, où janvier est 1).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.month\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-second-of-minute"]={
      script="-- Lua Function to set value to second of minute\n-- Sets each data point's value to its second of the minute (0-59)\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-second-of-minute\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Second of Minute\",\n\9\9[\"de\"] = \"Wert zu Sekunde der Minute\",\n\9\9[\"es\"] = \"Valor a segundo del minuto\",\n\9\9[\"fr\"] = \"Valeur à la seconde de la minute\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its second of the minute (0-59).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf seine Sekunde der Minute (0-59).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su segundo del minuto (0-59).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur sa seconde de la minute (0-59).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.sec or 0\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-time-of-day"]={
      script="-- Lua Function to set value to time of day\n-- Sets each data point's value to the time of day in seconds since midnight\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-time-of-day\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Time of Day\",\n\9\9[\"de\"] = \"Wert zu Tageszeit\",\n\9\9[\"es\"] = \"Valor a hora del día\",\n\9\9[\"fr\"] = \"Valeur à l'heure de la journée\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to the time of day in seconds since midnight. The output is a duration value representing elapsed time since the start of the day.\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf die Tageszeit in Sekunden seit Mitternacht. Die Ausgabe ist ein Dauerwert, der die verstrichene Zeit seit Tagesbeginn darstellt.\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en la hora del día en segundos desde la medianoche. La salida es un valor de duración que representa el tiempo transcurrido desde el comienzo del día.\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur l'heure de la journée en secondes depuis minuit. La sortie est une valeur de durée représentant le temps écoulé depuis le début de la journée.\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9-- Get the date from the data point\n\9\9\9local date = core.date(data_point)\n\n\9\9\9-- Calculate seconds since midnight\n\9\9\9local seconds_since_midnight = (date.hour or 0) * 3600 + (date.min or 0) * 60 + (date.sec or 0)\n\n\9\9\9-- Set value to time of day in seconds\n\9\9\9data_point.value = seconds_since_midnight\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    },
    ["value-to-year"]={
      script="-- Lua Function to set value to year\n-- Sets each data point's value to its year\n\nlocal core = require(\"tng.core\")\n\nreturn {\n\9-- Configuration metadata\n\9id = \"value-to-year\",\n\9version = \"1.0.0\",\n\9inputCount = 1,\n\9categories = {\"_time\"},\n\9title = {\n\9\9[\"en\"] = \"Value to Year\",\n\9\9[\"de\"] = \"Wert zu Jahr\",\n\9\9[\"es\"] = \"Valor a año\",\n\9\9[\"fr\"] = \"Valeur à l'année\",\n\9},\n\9description = {\n\9\9[\"en\"] = [[\nSets each data point's value to its year (e.g., 2025).\n]],\n\9\9[\"de\"] = [[\nSetzt den Wert jedes Datenpunkts auf sein Jahr (z.B. 2025).\n]],\n\9\9[\"es\"] = [[\nEstablece el valor de cada punto de datos en su año (p. ej., 2025).\n]],\n\9\9[\"fr\"] = [[\nDéfinit la valeur de chaque point de données sur son année (par exemple, 2025).\n]],\n\9},\n\9config = {},\n\n\9-- Generator function\n\9generator = function(source)\n\9\9return function()\n\9\9\9local data_point = source.dp()\n\9\9\9if not data_point then\n\9\9\9\9return nil\n\9\9\9end\n\n\9\9\9local date = core.date(data_point)\n\9\9\9data_point.value = date.year\n\n\9\9\9return data_point\n\9\9end\n\9end,\n}\n",
      version="1.0.0"
    }
  },
  published_at="2025-11-03T19:27:40Z",
  translations={
    _addition={
      de="Addition",
      en="Addition",
      es="Suma",
      fr="Addition"
    },
    _all_fields={
      de="Alle Felder",
      en="All Fields",
      es="Todos los campos",
      fr="Tous les champs"
    },
    _arithmetic={
      de="Arithmetik",
      en="Arithmetic",
      es="Aritmética",
      fr="Arithmétique"
    },
    _case_sensitive={
      de="Groß-/Kleinschreibung beachten",
      en="Case Sensitive",
      es="Distinguir Mayúsculas",
      fr="Sensible à la Casse"
    },
    _compare_by={
      de="Vergleichen nach",
      en="Compare By",
      es="Comparar por",
      fr="Comparer par"
    },
    _cutoff={
      de="Grenzwert",
      en="Cutoff",
      es="Límite",
      fr="Limite"
    },
    _day={
      de="Tag",
      en="Day",
      es="Día",
      fr="Jour"
    },
    _days={
      de="Tage",
      en="Days",
      es="Días",
      fr="Jours"
    },
    _division={
      de="Division",
      en="Division",
      es="División",
      fr="Division"
    },
    _filter={
      de="Filter",
      en="Filter",
      es="Filtro",
      fr="Filtre"
    },
    _generators={
      de="Generatoren",
      en="Generators",
      es="Generadores",
      fr="Générateurs"
    },
    _hours={
      de="Stunden",
      en="Hours",
      es="Horas",
      fr="Heures"
    },
    _label_and_note={
      de="Label und Notiz",
      en="Label and Note",
      es="Etiqueta y nota",
      fr="Étiquette et note"
    },
    _label_only={
      de="Nur Label",
      en="Label Only",
      es="Solo etiqueta",
      fr="Étiquette uniquement"
    },
    _match_exactly={
      de="Exakt übereinstimmen",
      en="Match Exactly",
      es="Coincidir Exactamente",
      fr="Correspondance Exacte"
    },
    _max_value={
      de="Maximalwert",
      en="Max Value",
      es="Valor Máximo",
      fr="Valeur Maximale"
    },
    _min_value={
      de="Minimalwert",
      en="Min Value",
      es="Valor Mínimo",
      fr="Valeur Minimale"
    },
    _month={
      de="Monat",
      en="Month",
      es="Mes",
      fr="Mois"
    },
    _multiplication={
      de="Multiplikation",
      en="Multiplication",
      es="Multiplicación",
      fr="Multiplication"
    },
    _note_only={
      de="Nur Notiz",
      en="Note Only",
      es="Solo nota",
      fr="Note uniquement"
    },
    _on_missing={
      de="Bei Fehlen",
      en="On Missing",
      es="En Faltante",
      fr="En Cas de Manque"
    },
    _operation={
      de="Operation",
      en="Operation",
      es="Operación",
      fr="Opération"
    },
    _pass_through={
      de="Durchleiten",
      en="Pass Through",
      es="Pasar Sin Cambios",
      fr="Laisser Passer"
    },
    _period={
      de="Periode",
      en="Period",
      es="Período",
      fr="Période"
    },
    _period_multiplier={
      de="Periodenmultiplikator",
      en="Period Multiplier",
      es="Multiplicador de Período",
      fr="Multiplicateur de Période"
    },
    _randomisers={
      de="Zufallsgeneratoren",
      en="Randomisers",
      es="Aleatorizadores",
      fr="Générateurs Aléatoires"
    },
    _reset_label={
      de="Zurücksetzen-Label",
      en="Reset Label",
      es="Etiqueta de Restablecimiento",
      fr="Étiquette de Réinitialisation"
    },
    _reset_on_label_match={
      de="Zurücksetzen bei Label-Übereinstimmung",
      en="Reset on Label Match",
      es="Restablecer al Coincidir Etiqueta",
      fr="Réinitialiser sur Correspondance d'Étiquette"
    },
    _seed={
      de="Seed",
      en="Seed",
      es="Semilla",
      fr="Graine"
    },
    _skip={
      de="Überspringen",
      en="Skip",
      es="Omitir",
      fr="Ignorer"
    },
    _subtraction={
      de="Subtraktion",
      en="Subtraction",
      es="Resta",
      fr="Soustraction"
    },
    _time={
      de="Zeit",
      en="Time",
      es="Tiempo",
      fr="Temps"
    },
    _time_threshold={
      de="Zeitschwellwert",
      en="Time Threshold",
      es="Umbral de Tiempo",
      fr="Seuil de Temps"
    },
    _transform={
      de="Transformieren",
      en="Transform",
      es="Transformar",
      fr="Transformer"
    },
    _value_and_label={
      de="Wert und Label",
      en="Value and Label",
      es="Valor y etiqueta",
      fr="Valeur et étiquette"
    },
    _value_and_note={
      de="Wert und Notiz",
      en="Value and Note",
      es="Valor y nota",
      fr="Valeur et note"
    },
    _value_only={
      de="Nur Wert",
      en="Value Only",
      es="Solo valor",
      fr="Valeur uniquement"
    },
    _week={
      de="Woche",
      en="Week",
      es="Semana",
      fr="Semaine"
    },
    _weeks={
      de="Wochen",
      en="Weeks",
      es="Semanas",
      fr="Semaines"
    },
    _year={
      de="Jahr",
      en="Year",
      es="Año",
      fr="Année"
    }
  }
}